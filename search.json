[{"title":"Java Web(十一) JSP开发模型","date":"2020-11-03T16:00:00.000Z","url":"/blog/2020/11/04/BackEnd-2020-11-javaweb-11-jspmode/","tags":["Java","Java Web","JDBC"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(十一) JSP开发模型sun公司开发了JSP技术后，为我们提供了jsp的两种开发模型 Model1,Model2 JSP Model1在早期web项目开发中，只是使用jsp技术来完成所有操作，包括用jsp来接收用户请求，处理响应，处理数据等，这样就会造成jsp页面中存在大量java代码，导致程序混乱，不便与后期维护和二次开发，所以sun提出了jsp model1开发模型。 JSP Model1 = JSP + JavaBeanJSP负责业务操作以及数据显示，JavaBean负责处理数据优点：使用简单，技术要求低，主要用于小型web项目 JSP Model2Model2在Model1的基础上提出，新增了Servlet技术。 JSP Model2 = JSP + Servlet + JavaBeanJSP负责页面数据显示Servlet负责业务逻辑处理JavaBean处理数据优点：分层明显，利于后期维护和开发，适用于开发一些复杂的web项目 MVC 设计模式MVC即模型，视图，控制器 模型：模型层Model，用来管理应用程序的业务数据，定义访问控制以及修改这些数据的业务规划，当模型的状态发送改变时，通知视图层更新数据 视图：View，用来负责与用户进行交互，它从模型中获取数据向用户展示，同时也能将数据传递给控制器进行处理。其会根据模型中的数据保持一致。 控制器：Controller，负责应用程序的用户交互部分，接受视图传递过来的数据，并向模型发送数据。 JavaWeb开发中的三层架构web层，service层，dao层。 web层包含了jsp,servlet,javabean的相关内容，接受用户请求，处理请求，响应请求 service层也称为bussiness，处理业务逻辑操作 dao层DataBase Access Object，数据库持久化对象，数据层。即针对数据库的CRUD操作 在开发项目时先确定项目架构，再确定采用哪种设计模式 "},{"title":"Java Web(十) 数据库连接池和DBUtils","date":"2020-11-01T16:00:00.000Z","url":"/blog/2020/11/02/BackEnd-2020-11-javaweb-10-dbcpool-dbutils/","tags":["Java","Java Web","JDBC"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(十) 数据库连接池和DBUtils数据库连接池在使用jdbc编程时，每次访问数据库都需要创建链连接对象，访问完毕后也需要断开连接（销毁对象），当数据库访问量巨大时，将频繁创建和销毁连接对象，拉低数据库的执行效率。 数据库连接池技术 为了解决这个弊端，产生了数据库连接池技术来管理连接对象。通过数据库连接池将有以下优势： 应用程序不再需要创建和销毁连接对象，而是交给数据库连接池进行管理。 应用程序断开连接时，不再销毁对象继而将连接对象归还连接池。 不难看出数据库连接池技术和线程池异曲同工之妙。 数据库连接池的基本参数： 初始化连接数 最大连接数 最大等待时间 最大空闲连接 最小空闲连接 数据库连接池与传统模式的区别： DataSource接口 数据库连接池技术是基于DataSource接口实现，该接口由sun公司制定规范，数据库厂商提供接口实现自家的数据库连接池。 目前流行的数据库连接池技术有：DBCP 和 C3P0 DBCP 数据源DBCP (DataBases Connection Pool 数据库连接池),是由开源组织Apache提供的数据库连接池技术。 在项目中使用DBCP的基本步骤： 下载DBCP的jar包：commons-dbcp2-2.8.0.jar,commons-pool2-2.9.0.jar DBCP获取连接对象，设置连接参数。第一种：直接使用BasicDataSource类创建连接对象第二种：通过读取DBCP配置文件创建连接对象 C3P0 数据源C3P0数据源是目前主流的数据库连接池技术之一，其性能更加优越，还提供了数据框架hibernate等很好的支持。 在项目开发中使用C3P0的基本步骤： 下载C3P0的jar包并导入项目：c3p0-0.9.5.5.jar,mchange-commons-java-0.2.19.jar 设置连接参数第一种：通过ComboPoole构造方法获取第二种：通过读取配置文件进行配置 DBUtilsDBUtils 由开源组织Apache发布的commons组件，是对JDBC的封装工具类，减少了操作数据库的代码。 commons-dbutils-1.7.jar 下载地址 QueryRunner类QueryRunner类是DBUtils组件下的核心类，通常和ResultSerHandler接口配合使用。 query() 执行查询语句 update() 执行增删改语句(DDL) ResultSerHandler接口 处理ResultSet结果集对象，封装数据，转换成对象或集合 ResultSerHandler实现类： BeanHandler：把结果集中第一行的数据转化成javaBean对象 BeanListHandler：把结果集中所有数据转换成javaBean的List ScalarHandler：把结果集数据转换成对象 使用DBUtils实现CRUD"},{"title":"Java Web(八) Filter和Listener","date":"2020-11-01T16:00:00.000Z","url":"/blog/2020/11/02/BackEnd-2020-11-javaweb-8-filter-listener/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(八) Filter和ListenerFilter 过滤器对象在开发中，通过浏览器访问服务器端资源时，通过Filter可以拦截请求，如果Filter判断请求合理，允许访问目标资源否则拒绝访问请求，一个请求可以通过多个Filter。简单来说就是路由管理。 Filter的生命周期： init() doFilter() destroy() 实现第一个Filter通过创建class类继承Filter接口实现。 通过IDE直接创建一个Filter类。 拦截的具体配置会写入web.xml文件中 Filter 映射拦截匹配目录: 拦截请求方式： Filter 链在一个web项目中可以存在多个Filter对同一个请求进行拦截，这些Filter就被称为Filter链。多个过滤器拦截一个请求时，拦截顺序和web.xml的配置顺序有关，谁配置在前谁先拦截 FilterConfigFilterConfig是Filter的配置对象，用来获取与Filter相关的参数信息。 获取初始化参数值 获取所有的初始化参数名称 获取ServletContext对象 Filter 相关应用使用Filter实现用户自动登录 通过请求拦截判断cookie中存储的用户信息，并使用这些信息登录 Filter实现统一全站编码 旧版本需要处理Get请求中文乱码问题，解决方案为使用装饰者模式增强getParameter方法 Listenter 监听器对象Servlet监听器由四个重要部分组成： 事件 事件源 事件监听器 事件处理器 Servlet监听器有八种和三大类： 监听域对象的创建和销毁：request,session,servletContext 监听域对象属性的创建和销毁：setAttribute(),removeAttribute(),getAttribute() 监听session域对象中对象属性的状态 Listenter 的生命周期 监听器对象创建应在被监听对象之前创建，熟悉各个域对象的创建与销毁时期：ServletContext域对象：在服务器启动时创建，服务器关闭时销毁request对象：每次发起请求时创建，请求响应之后销毁session对象：在一次会话时创建，会话结束销毁，超过过期时间销毁，服务器关闭销毁，invalidate()方法销毁 通过IDE可以轻松创建一个Listener类。 demo::: details ::: 监听域对象属性变更在开发中经常使用的是监听域对象属性变更。 通过参数中的事件源可以得到修改的属性和属性值。"},{"title":"Java Web(九) JDBC","date":"2020-11-01T16:00:00.000Z","url":"/blog/2020/11/02/BackEnd-2020-11-javaweb-9-jdbc/","tags":["Java","Java Web","JDBC"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(九) JDBCJDBC 概述Java DataBase Connectivity , Java数据库连接，通过JDBC赋予了java操作数据库的能力，不同的数据库提供了不同的JDBC包。我们只需要在数据库官网下载相应的JDBC包并导入项目，即可使用java操作对应的数据库。 JDBC demo导入mysql-connector-java-8.0.21.jar到项目文件。 不建议使用DriverManager.registerDriver(driver)方法注册驱动，该方法会冗余注册两次。关闭连接的.close()方法尽量放在finally块中，防止因为前面的代码错误导致无法继续向下执行，造成连接未关闭。 PreparedStatment预编译对象 PreparedStatment和Statement语句都可以向数据库发送sql语句，执行CRUD操作Statement操作数据库时会每次都对sql语句进行编译，在执行大量相同的sql语句时会造成效率低下，而PreparedStatment操作数据库时会预先编译，大大减少执行时间。除此之外，PreparedStatment方式操作数据库能防止SQL注入。 注意 java.sql.Date(子类) 与 java.sql.Date(父类) 之间的关系 ResultSet结果集对象 封装查询出来的数据，调用next()方法跳转到下一行，逐个获取该行数据。关于滚动游标和游标的操作请自行查询相关文档。 DAO 模式DAO (DataAccessobjects 数据存取对象)是指位于业务逻辑和持久化数据之间实现对持久化数据的访问。通俗来讲，就是将数据库操作都封装起来。 对外提供相应的接口 在面向对象设计过程中，有一些”套路”用于解决特定问题称为模式。DAO 模式提供了访问关系型数据库系统所需操作的接口，将数据访问和业务逻辑分离对上层提供面向对象的数据访问接口。 从以上 DAO 模式使用可以看出，DAO 模式的优势就在于它实现了两次隔离。 隔离了数据访问代码和业务逻辑代码。业务逻辑代码直接调用DAO方法即可，完全感觉不到数据库表的存在。分工明确，数据访问层代码变化不影响业务逻辑代码,这符合单一职能原则，降低了藕合性，提高了可复用性。 隔离了不同数据库实现。采用面向接口编程，如果底层数据库变化，如由 MySQL 变成 Oracle 只要增加 DAO 接口的新实现类即可，原有 MySQ 实现不用修改。这符合 “开-闭” 原则。该原则降低了代码的藕合性，提高了代码扩展性和系统的可移植性。 一个典型的DAO 模式主要由以下几部分组成： DAO接口： 把对数据库的所有操作定义成抽象方法，可以提供多种实现。 DAO 实现类： 针对不同数据库给出DAO接口定义方法的具体实现。 实体类：用于存放与传输对象数据。 数据库连接和关闭工具类： 避免了数据库连接和关闭代码的重复使用，方便修改。 Demo::::detailsDAO 接口: DAO 实现类: 宠物实体类(里面get/set方法就不列出了): 连接数据库: :::"},{"title":"Java Web(七) EL表达式和JSTL标签库","date":"2020-10-31T16:00:00.000Z","url":"/blog/2020/11/01/BackEnd-2020-11-javaweb-7-el-jstl/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(七) EL表达式和JSTL标签库JavaBeanJavaBean 是java开发中常用的组件，其实就是一个java类，用于封装数据。书写JavaBean需要满足五个规范： 该类被public修饰 该类提供公共无参构造方法 该类要有私有属性 该类的私有属性必须有get和set方法 该类要实现Serializable接口(可选) JavaBean的属性类的成员变量和属性的关系：在普通的java类里面，成员变量可以说成是属性，但是在javabean里，只有能被get&amp;set的成员变量才被称为属性。 BeanUtilsBeanUtils 是apache提供的一套封装JavaBean的工具类。要想使用BeanUtils工具类，需要导入相关jar包到项目。 commons-beanutils-1.9.4.jarcommons-logging-1.2.jar BeanUtils常用API: setProperty 设置javabean属性值 基础语法： getProperty 获取javabean的属性值 基础语法： populate 设置javabean属性值通过map集合 参数说明： properties：map key 对应javabean attr, map value 对应javabean attr-val BeanUtils常用来封装表单的提交数据，因为request提供了getParameterMap()方法将提交参数合并为一个map对象，我们可以直接使用BeanUtils的populate()方法直接封装数据 注意BeanUtils是JavaWeb项目的第三方jar包，在其他项目下你可能无法这种使用它。使用BeanUtils时，还需要注意属性名和值的对应关系。 EL 表达式EL Expression Language 在开发中通常用来获取域对象中保存的值。 基本语法 当el表达式中的值不存在时，不会在页面中显示任何信息，即返回”” EL 标识符 在el书写过程中，使用一些符号来标记变量，函数名等。 书写规范： 不能以数字开头 不能包含el关键字：and,or等 不能使用el表达式的隐式对象 不能包含特殊符号：\\ / : , = EL 变量 基本格式：$&#123;object&#125;，其中的objec就可以理解为el中的变量，无需定义可以直接使用。 EL 常量 布尔常量，数字常量，字符串常量，null常量 EL 运算符 点运算符，方括号运算符，算术运算符，比较运算符，逻辑运算符，empty运算符，三目运算符 EL 隐式对象pageContext pageScope,requestScope,sessionScope,applicationScope 作用域的隐式对象是为了解决各个域中的重名获取问题，默认从小范围开始寻值。 param,paramValues 当前页面中表单提交参数对象 cookie JSTLJSP标准标签库（JSTL JSP Stander Tag Libray）是一个JSP标签集合，它封装了JSP应用的通用核心功能。 JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。 根据JSTL标签所提供的功能，可以将其分为5个类别。 核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 JSTL下载和使用前往apache官网下载 taglibs-standard-impl-1.2.5.jar和taglibs-standard-spec-1.2.5.jar两个jar包，将其导入项目即可。 上面的链接指向了1.2版本的，如果你需要使用旧版本即1.1版本的可以前往apache release下载jakarta-taglibs-standard-1.1.2.zip解压该文件后将lib目录下的jstl.jar和standard.jar引入项目文件即可。 将jar包导入项目，在jsp文件中通过taglibs引入标签库。 在jsp中使用标签测试是否引入成功 JSTL 标签&lt;c:out&gt; 向网页输出内容 参数说明： value：输出内容 default：输出内容不存在时，显示默认值 escapeXml：原文输出和HTML输出，默认true &lt;c:if&gt; 条件判断 实例： &lt;c:choose&gt; 条件选择 实例： &lt;c:forEach&gt; 遍历域对象或集合 实例： 输出： 如同前端的模板语法一样，&lt;c:forEach&gt;标签也拥有一些索引属性 注意区分序号和索引的区别，序号指当前输出元素的序数，索引指的是当前元素在集合中的下标 &lt;c:url&gt; &lt;c:param&gt; 传递参数和设置路径 实例： "},{"title":"Java Web(六) JSP","date":"2020-10-27T16:00:00.000Z","url":"/blog/2020/10/28/BackEnd-2020-10-Javaweb-6-jsp/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(六) JSPJSP (Java Server Pages)，java服务器端页面，是一种建立在servlet规范基础上的动态网页开发技术，JSP 允许书写 java 代码和 html 标签，它运行在服务器端，其本质就是一种servlet。 这和 JS 前端的模板语法十分相似，都是为了解决向前端页面书写后台数据的需求，其摆脱了在servlet中通过字符串拼接来解决该需求的落后性，使代码更加规范简洁。 编写第一个JSP在使用 Eclipse 在你的项目下创建第一个 JSP 文件时，我们需要修改一下 Eclipse 中创建 JSP 文件使用的模板中的编码变量参数。 Windows -&gt; Prederences -&gt; Web -&gt; JSP File修改Encoding项为 ISO 10645/Unicode(UTF-8) 示例： JSP文件会生成java文件，编译成class后，会托管到tomcat的/work目录下，通过查看其源码，不难发现其说继承servlet实现的。 JSP 运行原理JSP文件本质是Servlet的另一种实现，其本质依旧是一个servlet。 JSP 基础语法要想在JSP文件中书写java代码，就需要使用固定的JSP语法格式。 JSP 脚本在JSP页面书写java的三种方式 JSP Scriptlets 声明语句 表达式 示例代码：:::details hello.jsp 页面输出： ::: JSP 注释html注释 java注释 jsp注释 示例代码：::: details ::: JSP 指令page指令 page指令用于设置与jsp页面的相关信息，如jsp编码格式，默认语言等。常用属性： language: 默认java pageEncoding：设置页面编码格式 contentType: 内容类型 session：true(default)/false，设置该页面是否可以使用session import：和java项目中一样，为页面内的java代码导入相应的包 include指令 通过include指令我们可以在当前页面中包含其他的页面，这种方式又称为静态包含，其特点是： 把多个页面的内容合并输出 多个页面生成一个java文件，编译成一个class文件 这种方式与前端模板语法的模板套用十分相似。 实例：::: detailsinclude.jsp date.jsp ::: JSP 隐式对象通过查看jsp文件的生成的java文件不难发起，在该类预定义了一些对象，在jsp文件中使用这些对象就可以直接调用。 request：HttpServletRequestresponse：HttpServletResponsesession：HttpSessionapplication：ServletContextconfig：ServletConfigout：JspWriter,PrintWriterpage：Object，代表当前jsp页面对象pageContext：PageContextexception：Throwable，异常对象，用来捕获异常信息 仅当page指令设置参数isErrorPage=&quot;true&quot;时，才会拥有exception隐式对象 out 对象out对象的优先级问题(了解即可) 访问上方页面，发现输出为： 这涉及jsp文件的编译过程和相关对象的优先级问题 pageContext 对象pageContext是开发过程中常用的一对象，通过pageContext对象，能够获取其它八个隐式对象和操作三个域对象request,session,application 获取其他隐式对象方法:getRequest()getResponse()getOut... 操作其他域对象的存取值：setAttribute(String name, Object obj, int scope)getAttribute(String name, int scope)findAttribute(String name) 参数说明 name：要设置的属性名称 value：要设置的属性值。 scope：要设置属性的范围对象 scope 参数的取值有APPLICATION_SCOPE,REQUEST_SCOPE,SESSION_SCOPE,PAGE_SCOPE findAttribute的寻值过程 pageContext -&gt; request -&gt; session -&gt; application，即从小范围到大范围查找。 如果你无法使用这些方法和属性，你需要在tomcat/lib下寻找jsp-api.jar包导入至项目 exception 对象通过exception对象，我们能够捕获到页面中的异常，想要使用exception对象必须设置相应的page指令属性isErrorpage=&quot;true&quot; 实例：::: detailsexception.jsp error.jsp out: ::: JSP 动作元素include实现页面包含 基础语法： 参数说明 page：被包含的页面路径 flush：true立即包含，包含完毕后在输出，false 先输出当前页面，再加载被包含文件 动态包含会生成多个java文件和class编译文件静态包含只会生成一个合并后的java文件和class文件 实例：::: detailsdynamicInclude.jsp included.jsp ::: forward实现请求转发，效果等同与RequestDispathcer.forward() 基础语法： 请求转发依旧是服务器内部行为，无需书写项目名称。 JSP 模板套用如同前端的模板语法一样，jsp提供相应的语法支持模板套用，从而提高代码的复用性。 新建index.jsp文件跳转到首页 页面分离与包含 注意处理文件路径问题。 "},{"title":"Java Web(五) 会话管理","date":"2020-10-25T16:00:00.000Z","url":"/blog/2020/10/26/BackEnd-2020-10-Javaweb-5-session/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(五) 会话管理会话是指，从用户打开网页窗口访问服务器到离开网页访问其他域（或关闭窗口），就是一次会话。一次会话可以包含多次请求，一次完整的会话只针对一个用户。 会话管理技术： cookie：客户端技术 session：服务端技术 其他对象存储数据的弊端： request:由于每次发起request请求都会产生一个request对象，导致某些累加的数据无法存储在request对象中。 ServletContext域对象：一个web项目只有一个ServletContext域对象，这样就会导致不同用户的信息不能区分存储，当然尽管能够通过数据结构的方式做到区分存储，但是这样会极大加重服务器的负担。 为了解决上述问题的存在，出现了会话管理技术cookie和session来管理会话过程中产生的数据。 Cookie 对象Cookie是一种会话管理技术，它是用来保存会话过程中产生的数据，cookie对象由服务器端创建,并将其响应给浏览器，浏览器接收cookie将其存储在用户本地浏览器空间中，当下次用户发起请求时只需要在请求头携带cookie对象 服务器端就能接收这次会话的发起者数据。 Cookie 对象常用 API得到cookie对象 回写cookie到浏览器 得到cookie名称和值 为cookie设置生命时长 为cookie设置路径，域名 Cookie 分类 会话级别cookie，浏览器关闭，cookie对象就销毁了 持久化cookie，通过setMaxAge()方法设置 实例显示用户上次访问的时间： 你可以尝试关闭浏览器，再打开浏览器查看重新访问网页，是否能记录上次访问时间。 Session 对象session是一种会话管理技术，用来保存会话过程中的数据，保存的数据存储在服务器端，session是基于cookie实现的。 HttpSession 对象常用API得到session：HttpSession session = getSession()得到session的ID：getId()设置session的生命时常：setMaxInactiveInterval(int interval)销毁session：invalidate() session域对象，作用范围是一次完整会话。存值：setAttribute(String key,Object obj)取值：getAttribute(String key)移除：removeAttribute(String key) Session 超时管理session具有生命时长，默认存活时间为30分钟。（Tomcat的/conf/web.xml中可查看设置） 你可以通过生命时长相关方法修改该参数。 实例：简单购物车 创建Book封装图书信息 创建BookDB，模拟数据库，里面保存图书 提供图书的购买页面：ListBookServlet 添加购物车：PurcharseServlet 回显购物车图书信息：CartServlet 如果浏览器禁用cookie，禁止用户访问并提示用户开启cookie Book.java::: details ::: BookDB.java::: details ::: ListBook.java::: details ::: PurcharseServlet.java::: details ::: CartServlet.java::: details ::: 实例：用户登录 提供User类，封装用户名和密码 提供首页html，提示欢迎用户登录：IndexServlet 提供登录servlet，处理登录请求 提供登出servlet，处理登出请求 User.java::: details ::: IndexServlet.java::: details ::: LoginServlet.java::: details ::: LoginOutServlet.java::: details ::: login.html::: details :::"},{"title":"Java Web(四) 基础实例","date":"2020-10-24T16:00:00.000Z","url":"/blog/2020/10/25/BackEnd-2020-10-Javaweb-4-example/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(四) 基础实例至此，你对Java Web已经有了基础的认知，现在开始一些实际需求的实现。下面的代码均是servlet类的实现，调用其参数 response 的方法。你均可以在 java ee api docs中查询相关方法与说明。 实例一：网页的定时跳转和定时刷新定时跳转到其他页面： 每秒刷新页面上的时间： 实例二：网页重定向 实例三：获取表单提交 实例四：用户登录 关于重定向地址为什么可以使用url路径而不是服务器的路径?当服务器的响应头中携带重定向参数时，浏览器就会执行重定向行为，并发起该路径的访问，所以说这个路径应该是浏览器端访问服务器的url。 实例五：防盗链Referer：防止盗链，通过Referer请求头判断来访用户的发起地址，如果不是自己的网站发起的请求，就不允许访问。 实例六：请求转发"},{"title":"Java Web(三) Servlet进阶","date":"2020-10-23T16:00:00.000Z","url":"/blog/2020/10/24/BackEnd-2020-10-Javaweb-3-servlet-2/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(三) Servlet进阶Servlet 虚拟路径映射servlet映射路径的三种方式: 完全目录匹配 如：/hello 通配目录匹配 如：/* 扩展名匹配 如：*.action（注意使用 /*.action这种写法是错误的） 优先级： 完全目录匹配 &gt; 通配目录匹配 &gt; 扩展名匹配 servlet多重映射：servlet多重映射是指一个servlet可以被多个访问路径访问。 servlet缺省当servlet的映射目录是/时，这就是一个缺省的servlet。缺省servle是为了处理资源找不到和错误访问路径的问题（404） ServletConfig对象servlet的配置对象，作用是获取与servlet的初始化参数,其子类是GeneriServlet和HttpServlet,其实例化是通过web服务器实现的。 ServletConfig 常用方法 方法 说明 getInitParameter(String name) 获取servlet初始化参数的值 getInitParameterNames() 获取servlet初始化参数名集合 getServletContext() 获取servletContext对象 getServletName() 获取servlet名称 获取一个 getServletConfig 对象通过继承GeneriServlet或HttpServlet类，调用其中的getServletConfig方法获取到一个ServletConfig对象。 实例代码： 访问/ServletConfigServlet输出： ServletContext对象ServletContext对象在web服务器(JVM)启动时就由web服务器创建，并且每个web项目只有一个ServletContext对象。作用是获取web项目的全局初始化参数，在web项目共享数据，获取web项目的资源文件； 获取一个 ServletContext 对象 通过ServletConfig对象调用getServletContext方法。 通过父类GeneriServlet方法getServletContext直接获取 实例代码： 访问/ServletContextServlet输出: ServletContext 域ServletContext对象就是一个域对象，指能在一定范围内存值取值。因为整个项目只有一个ServletContext对象，所以可以通过其实现多个servlet对象共享数据。域对象的相关方法： 存值：setAttribute(String key,Object obj); 取值：getAttribute(String key) 删值：removeAttribute(String key) 实例代码： 先访问/ShareDataServlet进行存值，之后访问/ShareDataToServlet就可以看见页面输出i saved by ShareDataServlet。 ServletContext 获取web资源文件通过ServletContext对象能够获取web项目下面文件的字节输入流，或者文件的绝对路径。 路径问题普通的java项目使用jdk编译java文件，文件路径是相对与工作空间的。但是web项目是运行在Tomcat服务器下的，其文件路径是相对与Tomcat服务器的。 HttpServletRequest对象请求：浏览器访问网址，发生表单提交等行为都会触发请求行为，常见的请求方式有get post delete put 等。 HttpServletRequest是一个接口，其父接口为 ServletRequest，在开发中通常使用 HttpServletRequest。 请求消息分为三部分：请求行，请求头，请求参数。 HttpServletRequest 对象常用方法获取请求行的相关方法： 方法 说明 实例 getMethod() 获取请求提交方式 GET getProtocol() 获取请求协议 HTTP/1.1 getContextPath() 获取根路径 /demo getServletPath() 获取servlet路径 /RequestServlet getRequestURI() 获取请求路径 /demo/RequestServlet getRequestURL() 获取请求完整路径  获取请求头的相关方法： 方法 说明 getHeader(String name) 获取请求头的信息 getHeaderNames() 获取请求头的名称集合 获取请求参数的相关方法： 方法 说明 getParameter(String name) 获取请求参数值 getParameterValues(String name) 获取请求参数的名称集合 getParameterMap() 获取所有值 获取其他常用对象的相关方法： 方法 说明 getRequestDispatcher() 获取该请求的调度器对象 获取请求参数实例代码： 解决请求参数的中文乱码问题处理get请求方式提交的中文乱码：使用 String 构造方法解决 post提交会将参数首先提交到request对象的缓冲区中，缓冲区默认编码是ISO8859-1,只需要将其设置成支持中文的编码即可 HttpServletRequest 传递数据利用Request对象传递数据是利用了其域对象的特性，在一次请求中可以通过其存值与取值。|方法|说明||—|—||setAttribute(String key, Obeject obj)|存值||getAttribute(String key)|取值||removeAttribute(String key)|移除值| HttpServletResponse对象响应：服务器根据浏览器的请求，返回相应数据到浏览器的行为。 HttpServletResponse 是一个接口，他的父接口是 ServletResponse，在开发中通常使用 HttpServletResponse，通过HttpServletResponse我们可以设置响应数据的相关参数。 响应信息分为三部分：响应行，响应头，响应正文（响应体） HttpServletResponse 对象常用方法设置响应行和响应头的相关的方法：| 方法|说明|| —|—||setStatus(int sc)| 返回响应状态码，常见响应状态码：200 302 400 404 500 等。 ||setError(int sc)| 发送错误状态码 ||setStatus(int sc, String msg)| 发送错误状态码和错误信息||setHeader(String key, String value)|一对一键值对||addHeader(String key, String value)|一键对多值||setContentLength(int src)|设置响应数据长度||setCharacterEncoding(String a)|设置编码方式，参数为码表格式 utf-8||setContentType(String a)|设置响应数据的类型和码表格式 text/html;charset=utf-8| 发送响应体相关的方法：| 方法|说明|| —|—||getoutputStream|得到一个字节流ServletOutputStream对象，返回文本，图片，视频等二进制文件||getWriter()|得到一个字符流PrintWriter对象，返回字符数据| 通过字节和字符流返回响应字符串： 解决中文输出乱码的问题通过字节流向浏览器输出中文时可能会出现乱码问题，其原因是服务器端和浏览器端的编码格式不一致引起的。解决方式就是使服务器端编码和浏览器端编码保持一致。 通过字符流向浏览器输出中文时一定是乱码的，乱码形式:???，中文的编码格式iso8859-1，这种编码格式不支持中文。解决方法是设置服务器端编码为utf-8，注意这和上面的字节流处理方式有区别。 RequestDispatcher 对象在开发中，当web资源被访问到以后，需要服务器跳转到另一个web资源去处理请求，可以通过sendRedirect这个方法实现，转发对象的forward方法。 得到一个RequestDispatcher对象 RequestDispatcher对象常用方法：|方法|说明||—|—||forward(request,response)|请求转发||include(request,response)|请求包含| 请求转发和重定向请求转发和重定向虽然实现的功能一致，但是其内部实现原理是不同的，必须明确两者的整个流程。 请求转发 通过调用RequestDispatcher.forward()方法，将当前的request发送给指定servlet对象 请求重定向 重定向的requset是无法携带参数，因为浏览器无法在第二次发起请求时，无法处理第一次请求响应的数据并携带其至第二次请求中。 请求包含请求包含又不同于另外两个方式，请求包含是在服务器内部完成的，其路径和请求转发一样也不需要携带项目名称。与请求转发不同的是，这种方式最终响应浏览器的是初始请求的servlet。 实例代码： 访问/RequestIncludeServlet，查看网页： 注意，虽然被包含的servlet操作了response但是这个response对象最终依旧是归原servlet握有的，也是由原servlet响应给客户端的。（通过中文编码测试可验证） 请求转发和页面重定向可以从浏览器明显感觉到，页面重定向会刷新页面并更改页面的url地址，但是请求转发只会发起一次请求，自始至终url也没有变化。 "},{"title":"Java Web(二) Servlet基础","date":"2020-10-18T16:00:00.000Z","url":"/blog/2020/10/19/BackEnd-2020-10-Javaweb-2-servlet/","tags":["Java","Java Web"],"categories":["FrontEnd","BackEnd"],"content":"Java Web(二) Servlet 基础Servlet概述什么是servlet servlet 是运行在 Web 服务器中的小型 Java 程序。简单来说就是一个java类，在使用servlet时，需要导入javax.servlet下的jar包。比如：Tomcat服务器就提供了servlet的jar包，所以在开发时使用tomcat服务器就不需要再导入servletd的jar包（某些IDE或JDK集成了servlet，如 MyEclipse） Servlet也是一个资源，用户也能访问，他同时也是一个动态资源 servlet作用 servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求 Servlet 基础查询 JavaEE-API文档中的Servlet类，该类主要有五个方法 (文档描述) 返回 方法 描述 void init(ServletConfig config) servlet 容器仅在实例化 servlet 之后调用 init 方法一次。在 servlet 可以接收任何请求之前，init 方法必须成功完成。 ServletConfig getServletConfig() 返回 ServletConfig 对象，该对象包含此 servlet 的初始化和启动参数。返回的 ServletConfig 对象是传递给 init 方法的对象。 此接口的实现负责存储 ServletConfig 对象，以便此方法可以返回该对象。实现此接口的 GenericServlet 类已经这样做了。 void service(ServletRequest req, ServletResponse res) 由 servlet 容器调用，以允许 servlet 响应某个请求。 此方法仅在 servlet 的 init() 方法成功完成之后调用。 应该为抛出或发送错误的 servlet 设置响应的状态代码。 servlet 通常运行在可同时处理多个请求的多线程 servlet 容器中。开发人员必须知道要同步对所有共享资源（比如文件、网络连接以及 servlet 的类和实例变量）的访问。 String getServletInfo() 此方法返回的字符串应该是纯文本，不应该是任何种类的标记（比如 HTML、XML，等等）。 这个方法在开发中几乎不使用。 void destroy() 由 servlet 容器调用，指示将从服务中取出该 servlet。此方法仅在 servlet 的 service 方法已退出或者在过了超时期之后调用一次。在调用此方法之后，servlet 容器不会再对此 servlet 调用 service 方法。 此方法为 servlet 提供了一个清除持有的所有资源（比如内存、文件句柄和线程）的机会，并确保任何持久状态都与内存中该 servlet 的当前状态保持同步。 创建Servlet的三种方式 直接实现Servlet接口 继承GenericServlet类 继承HttpServlet类 一般开发中，创建servlet通常去继承HttpServlet类，如： 暴露接口和继承是为了将来新的技术出现时可以同步接口技术，如HttpsServlet预留未来的开发接口 Servlet 的生命周期从servlet被创建，被调用，到最终被销毁，整个过程就是servlet的生命周期与servlet生命周期相关的三个方法： **init()**：初始化 **service()**：服务方法 **destroy()**：销毁 servlet生命周期测试实例： 注意修改相应的web.xml访问路径和执行的servlet方法 访问  查看控制台输出 Servlet 源码解析 HttpServlet浏览器访问服务器端资源时需要遵守网络传输协议，比如http,https,file等，所以在创建servlet时,我们一般通过继承HttpServlet类来实现。 如果你需要查看HttpServlet的源码，你需要前往Tomcat官网下载Source Code Distributions源码压缩包，并在项目引入的servlet-api.jar中绑定源码文件 以下是部分HttpServlet类的源码： 在HttpServlet里重写方法时，一般不会重写其内部service方法，因为在其方法内部，最终调用了doGet,doPost等方法，所以我们只需要重写其doGet和doPost等方法 继承HttpServlet实例代码： Servlet ON Eclipse项目导入servlet-api.jarEclipse并不提供和支持自动导入servlet包，需要我们手动为项目导入jar包。Tomcat/lib目录下的servlet-api.jar提供了jar包我们直接将其复制到项目的WebContent/WEB-INFO/lib下即可，成功复制导入之后在项目的JavaResources/Libraries下会新增Web App Libraries/servlet-api.jar。 整个WEB项目的jar包都应该通过这种方式导入到项目中，即复制jar到WebContent/WEB-INFO/lib目录下，这对项目可移植性友好。 在Eclipse开发工具中创建Servlet的两种方式1. 手动创建Servlet继承GenericServlet，部署到tomcat服务器第一种是创建普通java类，通过实现Servlet接口或继承HttpServlet(GenericServlet)类。之后，你还需要手动在web.xml中配置访问该servlet的访问信息。 创建HelloServlet类，继承GenericServlet 重写父类GenericServlet的service方法 在service方法里面，处理客户端请求，把数据返回客户端 客户端想要访问Servlet，需要提供servlet的访问路径，在web.xml中键入地图指向。你可以右键实现的servlet类，点击复制限定名即可快速复制该类在项目中的路径引用。 托管项目到Tomcat服务器，访问设置的路径查看是否成功  2. 使用新建Servlet类的方式，自动创建第二种是通过开发工具新建Servlet，这种方式会自动向web.xml中添加访问该servlet的访问信息。 通过Eclipse创建servlet时，弹出窗口会引导你填写servlet名，描述，该Servlet的访问路径，重写的请求方法等。 以下是通过Eclipse新建的servlet类的部分代码： &#123;18&#125; 可以看见，其通过继承HttpServlet类的方式实现servlet，此外注意高亮标识行，其在doPost方法中调用了doGet方法，这是为了简化开发，即允许同一种需求使用Get和Post请求完成服务。"},{"title":"Tomcat 服务器安装与使用","date":"2020-10-18T16:00:00.000Z","url":"/blog/2020/10/19/BackEnd-2020-10-Tomcat-install-guide/","tags":["Java Web","Tomcat"],"categories":["BackEnd"],"content":"Tomcat 服务器安装与使用Web程序开发中常用的服务器有： Tomcat:Tomcat是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选，Apache开源组织项目，免费 weblogic:WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。Oracle公司，收费 websphere:WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。IBM公司，收费 Tomcat 的安装与使用1. 两种安装方式： 前往官网下载压缩包，解压使用（绿色免安装）：Apache Tomcat 官网下载安装程序，作为windows服务安装 (解压 /bin 下执行) 2. 启动和关闭Tomcat服务启动的三种方式 在解压后的/bin目录下执行startup.bat文件 运行tomcat9.exe启动 任务管理器启动tomcat服务测试开启成功与否：浏览器访问  启动成功会访问到tomcat页面 关闭 /bin目录下执行shutdown.bat文件 直接关闭挂载的命令行窗口 任务管理器关闭tomcat服务 开启服务的命令行窗口在服务运行时不要关闭，其挂载了服务器，一旦关闭服务器也会一起关闭 Tomcat 目录结构**/bin**：可执行文件**/conf/**：服务配置文件**/lib**：运行所需的依赖库jar**/logs**：日志文件存储目录**/temp**：运行时产生的临时文件**/wepapps**：存放运行的web项目**/work**：存放jsp产生的servlet文件 Tomcat 诊断tomcat启动常见的两种问题： 运行startup.bat时，命令行一闪而过：未正确配置JAVA_HOME环境变量 端口号被占用 socket bindException：解除端口占用或修改/conf/serve.xml文件更换端口 Tomcat 启动命令行乱码问题修改tomcat的conf下的logging.properties中的参数为GBK "},{"title":"Java Web(一) 开发入门","date":"2020-10-17T16:00:00.000Z","url":"/blog/2020/10/18/BackEnd-2020-10-Javaweb-1-init/","tags":["Java","Java Web","Tomcat"],"categories":["FrontEnd","BackEnd"],"content":" Java Web(一) 开发入门基础概念web网页资源分为两类： 静态资源：html, css, javascript 等，用户访问不会发生变化的资源数据 动态资源：jsp, servlet, php, asp 等，不同用户访问查看的数据资源不同 web开发中的常见两种模式： **B/S**：browser 和 server，浏览器和服务器模式，如淘宝，京东，天猫等 **C/S**：client 和 server，客户端和服务器模式，如QQ，微信，火绒等 B/S和B/S两种模式的区别：B/S模式可以不用安装客户端，直接使用浏览器访问网站，方便快捷，缺点：没有客户端，受网络影响明显B/S模式，可以在电脑或手机直接打开，访问速度快，缺点：服务端更新，客户端也需要更新 使用Eclipse构建第一个Web应用启动Eclipse打开工作空间，新建一个Web -&gt; Dynamic Web Project项目，之后Eclipse就会为您构建一个Web项目的基础构架。注意在最后一步时勾选 Generate web.xml deployment descriptor ，否则生成的项目将没有web.xml文件 (Dynamic web module version &gt;= 3.0 之后不再使用web.xml而是通过servlet的注释方式进行路径配置，但是并不建议入门跳过web.xml的认知) 基于Eclipse版本 web应用基本目录结构web应用就是一个web项目，web项目下有可供用户访问的网页资源 /src：存放java文件或配置文件/WebContent：存放网站内容/WebContent/WEB-INF/lib：项目运行依赖jar包/WebContent/WEB-INF/web.xml：项目配置信息/WebContent/classes：存放java被编译成的class文件 配置web项目访问的默认页面通过修改项目配置文件WebContent/WEB-INF/web.xml设置web项目访问的默认页面，如果该页面在文件中不存在，就顺序往下访问。示例：设置WebContent/hi.html文件为访问默认页面： 如果你在使用 Eclipse 构建项目时没有勾选生成配置导致没有web.xml文件，也可以手动生成右键项目打开菜单 &gt; Java EE Tools &gt; Generate Deployment Descriptor Stub 为Eclipse配置Tomcat服务器假设你已经了解Tomcat服务器并成功启动。在Eclipse顶部工具条点击 Window -&gt; Preferences -&gt; Web Services -&gt; Serve and Runtime设置 Serve runtime 为你的 Tomcat 版本，并指定你的tomcat存放根目录 Tomcat 服务器安装与使用参考同名博文 设置web项目托管方式双击控制台Servers中的Tomcat服务器即可修改相关属性 配置项说明： 三个单选选择：这是选择web项目编译后的文件托管方式，第一项是存放在Eclipse的工作空间下第二项是存放在Tomcat的安装路径下第三项是使用用户自定义路径 Server path 是引用的tomcat存储根目录 Deploy path 存储在Tomcat安装路径下的哪个文件下（注意如果使用eclipse默认的选项，你将无法在Tomcat安装路径下查看，推荐更改为Tomcat的规范托管文件夹 webapps） 运行web项目第一种方式：鼠标右键项目菜单 -&gt; Run As -&gt; Run on Sever -&gt; Tomcat 即可第二种方式：右键点击项目Severs控制台窗口下的 Tomcat服务器 -&gt; Add and Remove 将项目托管至服务器区即可（推荐） 现在你就可以通过浏览器访问  来查看你的web应用了。"},{"title":"初识Oracle分布式数据库","date":"2020-10-14T16:00:00.000Z","url":"/blog/2020/10/15/BackEnd-2020-10-DDB-simple-guide/","tags":["Oracle"],"categories":["BackEnd"],"content":"Oracle 分布式数据库什么是分布式数据库数据物理上被存放在网络的多个节点上，逻辑上是一个整体 分布式数据库的独立性分布数据库的独立性指用户不必关心数据如何分割和存储，只需关心他需要什么数据 Oracle 分布式RDBMS本地操作 远程操作 分布操作 跨节点数据的创建及查询 跨节点数据更新 定义数据库链路 DBLINK 修改主机 tnsnames.ora 文件以创建连接的服务名替代使用IP地址 通过链路查询远端数据库 &#123;2&#125; 使用同义词替换远端数据库 使用同义词替换远端表名后，上述SQL语句已经与本地SQL语句无异，但是其实际上是访问的远端数据库数据，这样就达到了对用户欺骗，造成数据在本机上的效果。 建立远程表的本地视图 分布式数据库的其他操作插入操作： 数据复制： 分布式数据库的跨节点更新 快照定义快照维护关系表的异步副本，用于主表修改少，但频繁查询的表 触发器在主机上创建触发器，实现数据的同步更新 "},{"title":"Eclipse 安装与配置简明指南","date":"2020-10-09T16:00:00.000Z","url":"/blog/2020/10/10/Other-Eclipse-install-guide/","tags":["Eclipse","Java","Jdk"],"categories":["Others"],"content":"Eclipse 安装与配置简明指南JDK-13 及以上版本 jre 生成命令 Eclipse 汉化插件访问官网语言包项目下载相应语言包解压之后，将解压文件中的 eclipse 下的两个文件 feature 和 plugins 移动到 eclipse 的安装目录下的 dropins 文件夹中 Eclipse 为项目导入第三方 jar在资源管理栏中右键项目文件夹，选择 Build Path 在顶栏选择 Libraries 选择 modul path 点击右侧 Add External JARs 选择已下载解压的 jar 包 Eclipse 代码中文字符过小解决两种方案： 把字体设置为 Courier New ：Windows -&gt; Preferences -&gt; Genneral -&gt; Appearance -&gt; Colors and Font -&gt; 在右侧框展开Basic -&gt; Text Font 点击Edit 按钮，在弹出窗选择 Courier New 将脚本修改为 中欧字符 ：windows -&gt; Preferences -&gt; Genneral -&gt; Appearance -&gt; Colors and Font 在右侧选中 Text Font 点击 Edit 按钮， 将 西欧语言 改成 中欧字符 推荐使用第二种解决方案，Consolas 字体个人感觉比 Courier New 好看 Eclipse 代码补全默认情况下 Eclipse 的代码补全是在键入 . 之后出现的，不像其他 IDE 键入任意字母提示补全。如果需要同其他 IDE 一样，需要自行修改补全规则 Window --&gt; Perferences --&gt; Java --&gt; Editor --&gt; Content Assist 在 Auto Activation 栏中勾选 Enable auto activation ，并设置 Auto activation triggers for java 选项为 .qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM 即二十六个字母 Eclipse 修改类注释文档的@author字段Eclipse默认情况下使用/**自动创建类注释文档时@author字段默认是计算机的用户名，如果你需要修改成你的开发名，可以以下操作设置Window --&gt; Perferences"},{"title":"MySQL 免安装版配置","date":"2020-10-09T16:00:00.000Z","url":"/blog/2020/10/10/BackEnd-2020-10-MySQL-uninstall-version-guide/","tags":["MySQL"],"categories":["BackEnd"],"content":"MySQL 免安装版配置为什么使用免安装版？ 绿色无污染 便携轻量 灵活可控 开始 前往 MySQL 官网下载免安装版MySQL Community Downloads 下载解压至任意目录，这里解压到 C:/MySQL 为例，解压后得到以下目录结构 配置环境变量： 检查是否设置成功命令行键入 mysql --version如果显示失败，检查环境变量的设置 在 C:/MySQL/mysql-8.0.21-winx64/ 下新建 my.ini 文件（可选，如无特殊需求不建议自行配置） 使用管理员权限打开 CMD 执行安装命令（如果忽略 .ini 文件，一切都按默认进行配置） 执行 MySQL 初始化命令，在 mysql-8.0.21-winx64 目录下就会生成 data 文件夹 启动 MySQL 服务 命令行访问数据库 mysql 正常语法 设置 root 密码 使用 quit 或 exit 退出 mysql 命令符，再执行修改密码操作如无设置密码可忽略 -p 参数 其余控制命令关闭 MySQL 服务 卸载 MySQL 查看服务状态 (mysql命令) "},{"title":"Navicat Premium 15 连接本机 OracleDB","date":"2020-10-09T16:00:00.000Z","url":"/blog/2020/10/10/BackEnd-2020-10-Navicat-connect-oracledb/","tags":["OracleDB"],"categories":["BackEnd"],"content":"Navicat Premium 15 连接本机 OracleDB 本教程基于作者学校机房环境的特殊配布，请酌情参考 开始之前你需要清楚当前计算机的OracleDB环境和版本 Oracle Database 版本： Oracle Database 在本机的安装路径： Oracle Database 管理员账号： 除此之外，你还需要知道两个必要的 OracleDB 服务进程 在本机中 OracleServiceORCL 服务默认是禁用的，你需要进入服务详情页右键属性更改为自动之后，才能正常启动 开始1. 修复 OracleOraDb11g_home1TNSListener 服务 ​ 由于本机的历史遗留问题导致 OracleOraDb11g_home1TNSListener 服务无法正常启动，需要手动修复。（OracleDB安装时的计算机名为PCxx，可能由于机房环境更改计算机名变更为VOIPCxx） 打开目录 C:\\app\\hp\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN 打开文件 listener.ora 修改相关属性 打开 tnsnames.ora 修改相关属性 你也可以直接使用本教程目录下 ADMIN 文件夹中同名文件进行替换 一般只要修改这两个文件后 OracleOraDb11g_home1TNSListener 服务便可以正常启动，如果你仍然无法启动确保你修改的值正确，或执行以下操作 新添系统环境变量 （非必需） 修改 OracleOraDb11g_home1TNSListener 注册表 （非必需） 使用 win + r 打开运行，输入 regedit 回车进入注册表编辑器 查找目录 修改其 ImagePath 属性为 C:\\app\\hp\\product\\11.2.0\\dbhome_1\\BIN\\TNSLSNR.EXE 至此对 OracleOraDb11g_home1TNSListener 服务的修复已经完成。 2. 重启数据库关键进程 在任务管理器中重启以下两个进程 3. 安装 Navicat Premium 15 并按照图片填写相关值 在连接之前，你必须在数据库中创建一个账号，你无法使用管理员账号进行连接 创建账号步骤： 按住 shift 键在桌面空白处点击鼠标右键，点击 在此处打开 Powershell 键入 sqlplus system/a123 as sysdba 命令，即以管理员身份登陆数据库 创建账号并授权 测试连接 点击测试连接，连接成功（如果失败，请逐步排查） 开启远程连接配布由于机房环境问题，如果需要开启OracleDB的远程连接，需要对 listener.ora 新增属性，注意缩进严格。 "},{"title":"Ajax 编程扩展（一）","date":"2020-08-26T16:00:00.000Z","url":"/blog/2020/08/27/BackEnd-2020-8-Ajax-more-1/","tags":["Node.js","Ajax"],"categories":["FrontEnd","BackEnd"],"content":" Ajax应用模板引擎 FormData 对象 同源政策 JSONP 解决方案 CORS 跨域资源访问 模板引擎作用：使用模板引擎提供的模板语法，可以将数据和 HTML 拼接起来。 下载 art-template 在 HTML 中引入 准备 art-template 模板 数据注入 插入页面 数据拼接 完整实例 ::: details ::: 案例验证邮箱地址唯一性 获取文本框并为其添加离开焦点事件 离开焦点时，检测用户输入的邮箱地址是否符合规则 如果不符合规则，阻止程序向下执行并给出提示信息 向服务器端发送请求，检测邮箱地址是否被别人注册 根据服务器端返回值决定客户端显示何种提示信息 邮箱验证正则表达式 完整源码 ajax 完整封装，后面的案例都将引用该方法 ::: details ::: 网站服务器响应，模拟数据库查询，后续案例将只书写关键部分 ::: details ::: 完整html实现源码，后续将只给出关键代码 ::: details ::: 搜索框内容自动提示 获取搜索框并为其添加用户输入事件 获取用户输入的关键字 向服务器端发送请求并携带关键字作为请求参数 将响应数据显示在搜索框底部 源码 服务器端数据库查询模拟 ::: details ::: 实现 ::: details ::: 省市区三级联动 通过接口获取省份信息 使用JavaScript获取到省市区下拉框元素 将服务器端返回的省份信息显示在下拉框中 为下拉框元素添加表单值改变事件（onchange） 当用户选择省份时，根据省份id获取城市信息 当用户选择城市时，根据城市id获取县城信息 关键源码 ::: details ::: FormDataFormData 作用 模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 异步上传二进制文件（图片，音频） FormData 使用 准备 HTML 表单 将 HTML 表单转化为 formData 对象 提交表单对象（仅 POST 请求） 注意： Formdata 对象不能用于 get 请求，因为对象需要被传递到 send 方法中，而 get 请求方式的请求参数只能放在请求地址的后面。 服务器端 bodyParser 模块不能解析 formData 对象表单数据，我们需要使用 formidable 模块进行解析。 FormData 方法获取表单对象属性值 设置表单对象中属性值 不存在，创建 存在，覆盖原有值 删除表单对象中属性值 追加表单对象中的属性值 注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 FormData 二进制文件上传 FormData 文件上传进度提示 FormData 文件上传图片即时预览在我们将图片上传到服务器端以后，服务器端通常都会将图片地址做为响应数据传递到客户端，客户端可以从响应数据中获取图片地址，然后将图片再显示在页面中。 文件上传完整源码完成图 app.js ::: details ::: index.html ::: details ::: 同源政策Ajax 请求限制Ajax 只能向自己的服务器发送请求。比如现在有一个A网站、有一个B网站，A网站中的 HTML 文件只能向A网站服务器中发送 Ajax 请求，B网站中的 HTML 文件只能向 B 网站中发送 Ajax 请求，但是 A 网站是不能向 B 网站发送 Ajax请求的，同理，B 网站也不能向 A 网站发送 Ajax请求。 什么是同源如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。 同源政策的目的同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。 随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 JSONPjsonp 是 json with padding 的缩写，它不属于 Ajax 请求，但它可以模拟 Ajax 请求。 将不同源的服务器端请求地址写在 script 标签的 src 属性中 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 在客户端全局作用域下定义函数 fn 在 fn 函数内部对服务器端返回的数据进行处理 JSONP 代码优化 客户端需要将函数名称通过请求参数传递到服务器端。 将 script 请求的发送变成动态请求。 封装 jsonp 函数，方便请求发送。 服务器端代码优化之 res.jsonp 方法。 案例：腾讯天气 JSONP访问腾讯天气官网 通过开发者工具抓取请求 common?source=pc... ，在新选项卡打开，不难发现其返回的是一个函数，函数的参数为对象，其存储了天气信息，且腾讯天气的域名和该请求的域名不同源，是典型的 JSONP 的应用。 腾讯天气抓包 请求返回数据 腾讯天气的接口文档 请求地址 请求方式 GET 支持 jsonp 参数 参数名 必选 类型 说明 source y string pc xw weather_type y string forecast_1h ：未来48小时 forcast_24h ：未来7天 province y string 省份 city y string 城市 返回值 完整源码 CORS 跨域资源共享CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 实例 服务器端代理跨域同源政策是浏览器给予Ajax技术的限制，服务器端是不存在同源政策限制。 withCredentials属性 在使用Ajax技术发送跨域请求时，默认情况下不会在请求中携带cookie信息。 withCredentials ：指定在涉及到跨域请求时，是否携带cookie信息，默认值为 false Access-Control-Allow-Credentials ：true 允许客户端发送请求时携带cookie 注意：如果允许携带 cookie 时，不能将Access-Control-Allow-Origin 设置为 * ，必须是具体的域名。"},{"title":"Ajax 编程基础","date":"2020-08-24T16:00:00.000Z","url":"/blog/2020/08/25/BackEnd-2020-8-Ajax-base/","tags":["Node.js","Ajax"],"categories":["FrontEnd","BackEnd"],"content":"Ajax 基础传统网站中存在的问题 网速慢的情况下，页面加载时间长，用户只能等待 表单提交后，如果一项内容不合格，需要重新填写所有表单内容 页面跳转，重新加载页面，造成资源浪费，增加用户等待时间 Ajax 概述Ajax：标准读音 [ˈeɪˌdʒæks] ，中文音译：阿贾克斯 它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。 简单来说，Ajax 是刷新网页部分数据的技术。 Ajax 应用场景 页面上拉加载更多数据 列表数据无刷新分页 表单项离开焦点数据验证 搜索框提示文字下拉列表 Ajax 运行环境Ajax 技术需要运行在网站环境中才能生效，当前课程会使用Node创建的服务器作为网站服务器。 使用 express 创建 Ajax 运行环境 此时你的项目结构应该为 Ajax 使用Ajax 运行原理Ajax 相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新页面数据，从而提高用户体验。 Ajax 实现步骤 创建 Ajax 对象 设置请求地址及请求方式 设置请求格式（可选） 发生请求 获取服务器端响应数据 ::: danger 代码顺序敏感，严禁错误的代码执行步骤 ::: 入门实例 ::: details &#123;13-24&#125; &#123;12-14&#125; ::: 响应数据格式在真实的项目中，服务器端大多数情况下会以 JSON 对象作为响应数据的格式。当客户端拿到响应数据时，要将 JSON 数据和 HTML 字符串进行拼接，然后将拼接的结果展示在页面中。 在 http 请求与响应的过程中，无论是请求参数还是响应内容，如果是对象类型，最终都会被转换为对象字符串进行传输。 实例 &#123;5&#125; 请求参数传递在传统网站都是以表单方式进行参数传递 在 Ajax 中我们可以手动设置请求参数 GET POST 实例 ::: details GET请求参数 &#123;14&#125; POST请求参数 &#123;8-10&#125; ::: 请求参数格式application/x-www-form-urlencoded application/json 在请求头中指定 Content-Type 属性的值是 application/json，告诉服务器端当前请求参数的格式是 json，尽管如此我们仍然不能直接传递 json 对象给服务器端，而是将 json 对象转换为json字符串再进行传递。 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 而在服务器端，想要接收 json 字符串则需要进行相应设置 实例 ::: details ::: 服务器端响应获取服务器端响应的另一种方式，已过时 Ajax 状态码 在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。 获取 Ajax 状态码 onreadystatechange 事件 当 Ajax 状态码发生变化时将自动触发该事件。 在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。 实例 ::: details ::: 两种获取服务器端响应方式的区别 区别描述 onload onreadystatechange 是否兼容IE低版本 不兼容 兼容 是否需要判断Ajax状态码 不需要 需要 被调用次数 一次 多次 Ajax 错误处理 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 网络畅通，服务器端没有接收到请求，返回404状态码。 检查请求地址是否错误。 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 服务器端错误，找后端程序员进行沟通。 网络中断，请求无法发送到服务器端。 会触发xhr对象下面的 onerror 事件，在 onerror 事件处理函数中对错误进行处理。注意，不再执行 onload 事件 IE 低版本缓存问题在低版本的 IE 浏览器中，Ajax 请求有严重的缓存问题，即在请求地址不发生变化的情况下，只有第一次请求会真正发送到服务器端，后续的请求都会从浏览器的缓存中获取结果。即使服务器端的数据更新了，客户端依然拿到的是缓存中的旧数据。 解决方案：在请求地址的后面加请求参数，保证每一次请求中的请求参数的值不相同。 Ajax 异步同异步概述同步：上一行代码执行完成后，才能执行下一行代码，即代码逐行执行。 异步：异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。 Ajax 便是典型的异步代码 Ajax 封装通过上面的代码，不难发现，发送一次请求代码过多，发送多次请求代码冗余且重复。 这是我们便需要将 Ajax 进行函数封装，方便调用 完整封装代码 "},{"title":"Node.js 入门（二）","date":"2020-08-23T16:00:00.000Z","url":"/blog/2020/08/24/BackEnd-2020-8-Node-start-2/","tags":["Node.js"],"categories":["BackEnd"],"content":" Node 服务器创建 浏览器请求处理 Promise 对象 异步函数 服务器端基础概念网站的组成网站应用程序主要分为两大部分：客户端和服务器端。 客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。 服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。 Node 网站服务器能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应。 IP地址互联网中设备的唯一标识。 IP是Internet Protocol Address的简写，代表互联网协议地址. 域名由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。 虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为ip才能访问到指定的网站服务器。 端口端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。 URL统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。 URL 的组成 http：超文本传输协议，提供了一种发布和接收HTML页面的方法。 创建web服务器 命令行运行 HTTP 协议HTTP协议的概念超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。 报文在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。 请求报文 请求方式 （Request Method） GET 请求数据 POST 发送数据 请求地址 （Request URL） 根据请求地址返回不同数据 响应报文 HTTP状态码 200 请求成功 404 请求的资源没有被找到 500 服务器端错误 400 客户端请求有语法错误 内容类型 text/plain text/html text/css application/javascript image/jpeg application/json HTTP 请求与响应处理请求参数客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。 GET请求参数 参数被放置在浏览器地址栏中，例如： 参数获取需要借助系统模块url，url模块用来处理url地址 POST请求参数 参数被放置在请求体中进行传输 获取POST参数需要使用data事件和end事件 使用querystring系统模块将参数转换为对象格式 路由  路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。 一个比较完整的路由和参数获取 静态资源服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件。 访问静态资源实例 动态资源相同的请求地址不同的响应资源，这种资源就是动态资源。   返回资源类型动态判断 客户端请求途径 GET请求 浏览器地址栏 link标签的href属性 script标签的src属性 img标签的src属性 Form表单提交 POST请求 Form表单提交 Node.js 异步编程同步异步API同步API：只有当前API执行完成后，才能继续执行下一个API 异步API：当前API的执行不会阻塞后续代码的执行 同异区别同步API可以从返回值中拿到API执行的结果, 但是异步API是不可以的 回调函数自己定义函数让别人去调用。 使用回调函数获取异步API执行结果 代码顺序分析同步API从上到下依次执行，前面代码会阻塞后面代码的执行 异步API不会等待API执行完成后再向下执行代码 Node.js中的异步API 如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢？ 回调地狱 需求：依次读取 A,B,C 文件 PromisPromise 出现的目的是解决 Node.js 异步编程中回调地狱的问题。 Promise 实例： Promise 解决回调地狱 异步函数异步函数是在 ES7 中新增的，其本质上是对 Promise 对象的封装，使得代码语法更加简洁 异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。 语法 async 普通函数定义前加async关键字 普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用 return 关键字进行结果返回 结果会被包裹的promise 对象中 return 关键字代替了 resolve 方法 在异步函数内部使用 throw 关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 依次读取文件的异步函数解决方案 "},{"title":"Node.js 入门（一）","date":"2020-08-23T16:00:00.000Z","url":"/blog/2020/08/24/BackEnd-2020-8-Node-start-1/","tags":["Node.js"],"categories":["BackEnd"],"content":" Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 Node 开发概述为什么要学习服务器端开发基础 能够和后端程序员更加紧密的配合 网站业务逻辑前置，学习前端技术需要后端技术支撑 （Ajax) 扩宽知识视野，能够站在更高的角度审视整个项目 服务器端开发要做的事情 实现网站业务逻辑 数据的增删改查 为什么选择 Node 使用 JavaScript 语法开发后端应用 一些公司邀请前端工程师掌握Node开发 生态系统活跃，有大量开源库可以使用 前端开发工具大多基于 Node 开发 什么是 NodeNode 是一个基于 Chrome V8 引擎的 JavaScript 代码运行环境 运行环境 浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境 Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境 Node 运行环境搭建Node.js 官网 版本说明： LTS ：Long Term Support 长期支持版 稳定版 Current ：拥有最新特性 实验版 安装路径请勿包含中文路径 安装完成后通过命令行工具键入下面命令查看是否安装成功 常见错误 **2502，2503 ** 错误原因：系统账户权限不足 解决方法 以管理员身份运行命令行 输入运行安装包命令 `msiexec /package nodePath.msi 无法识别命令 失败原因：Node安装目录写入环境变量失败 解决方法：手动设定Node安装路径到PATH环境变量 Node.js 快速入门Node.js 的组成 JavaScript 由三部分组成：ECAMScript , DOM , BOM Node.js 是由 ECMAScript 及 Node环境提供的一些附加API组成，包括文件，网络，路径等等一些更加强大的API Node.js 基础语法所有 ECMAScript 语法在 Node 环境中都可以使用 在项目文件下新建 index.js 文件，书写以下代码 在项目目录下打开终端，键入 node 命令运行 js 使用技巧 在资源管理器的工作目录中按住 Shift 键 + 鼠标右键，弹出的菜单内会出现在此处打开 PowerShell 窗口，此时的终端目录就会定位在当前目录下。 在使用 node 键入执行文件名时，可以使用 Tab 键自动补全 终端会记录命令历史，使用方向键上下可以切换历史命令 使用 cls 命令清空终端页面缓冲 Node.js 模块化开发JavaScript 开发弊端JavaScript 在使用时存在两大问题，文件依赖和命名冲突 由于 JavaScript 执行机制，当文件之间反复依赖，或相互依赖，会很难理清文件依赖关系。 如果文件与文件中存在相同命名的变量，可能会出现命名冲突 生活中的模块开发 电脑 屏幕 显卡 内存 鼠标 电源 软件中的模块化开发一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。 Node.js 模块化开发规范 Node.js 规定一个 js 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到 模块内部可以使用 exports 对象进行成员导出，使用 require 方法导入其他模块。 模块成员导出 模块成员引入 模块成员导出的另一种方式 两种导出方式的区别 区别：exports 是 module.exports 的别名（地址引用关系），导出对象最终以 module.exports 为准 系统模块Node 运行环境提供的 API ，因为这些 API 都是以模块化的方式进行开发的，使用我们又称 Node 运行环境提供的 API 为系统模块。 文件模块 fs filesystem : 文件系统 提供打印 fs ，可以获取到 fs 对象内的所有属性 ::: details ::: 读取文件内容 参数： path : 文件路径，包含文件 filecode : 文件编码，可选 callback ：回调函数，包含两个参数 err ：object 错误对象 如果错误抛出 null doc ：string 文件内容 实例 写入文件内容 参数： path : 文件路径，包含文件，需要写入的文件 data : 写入内容 callback ：回调函数 err ：object 错误对象 如果错误抛出 null 该方法会覆盖文件原有内容，如果文件不存在则会新建 实例 路径模块 path 为什么要进行路径拼接： 不同操作系统的路径分隔符不统一 windows 上是 \\ / linux 上是 / 语法 实例 相对路径与绝对路径 大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录，很多情况下，命令行工具的工作目录是经常改变的 在读取文件或者设置文件路径时都会选择绝对路径 使用 __dirname 获取当前文件所在的绝对路径 第三方模块什么是第三方模块 别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。 第三方模块存在的两种形式： 以js文件的形式存在，提供实现项目具体功能的API接口。 以命令行工具形式存在，辅助项目开发 获取第三方模块 npmjs.com ： 第三方模块的存储和分发仓库 npm (node package manager) ：node 包管理器 下载：npm install 模块名称 删除：npm uninstall 模块名称 本地安装和全局安装 默认进行本地安装，只有当前项目能够使用，一般库文件进行本地安装 全局安装是使用 -g 参数进行，能够让该计算机上的所有项目使用，一般对命令行工具进行全局安装 该命令会在命令行工作目录下创建 node_modules 和 packages-lock.json 两个文件，其中模块会存储在 node_modules 下。 nodemon nodemon 是一个命令行工具，用以辅助项目开发 在 Node.js 中，每次修改文件都要在命令行重新执行该文件，非常繁琐 而 nodemon 会为我们监控文件修改，一旦修改立即执行文件。 使用： 使用 npm install nodemon -g 下载 在命令行工具中使用 nodemon 命令替代 node 使用 ctrl + c 关闭监控 nrm nrm (npm registry manager): npm 下载地址切换工具 npm 默认下载地址在国外，国内下载速度很慢 使用： 使用 npm install nrm -g 下载 查询可用下载列表 nrm ls 切换 npm 下载地址 nrm use 名称 单独使用 cnpm： 使用命令下载 查看是否成功 cnpm -v 使用 cnpm 替代 npm 命令 Gulp gulp.js - 基于流(stream)的自动化构建工具。Grunt 采用配置文件的方式执行任务，而 Gulp 一切都通过代码实现。 基于node平台开发的前端构建工具 将机械化操作编写成任务, 想要执行机械化操作时执行一个命令行命令任务就能自动执行了 用机器代替手工，提高开发效率。 Gulp 能做什么 项目上线，HTML、CSS、JS文件压缩合并 语法转换（es6、less …） 公共文件抽离 修改文件浏览器自动刷新 Gulp 使用 下载 在项目根目录下建立 gulpfile.js 文件 重构项目的文件夹结构 src 目录放置源代码文件 dist 目录存放构建后文件 在 gulpfile.js 文件中编写任务 在命令行工具中执行 gulp 任务 Gulp中提供的方法 gulp.src()：获取任务要处理的文件 gulp.dest()：输出文件 gulp.task()：建立gulp任务 gulp.watch()：监控文件的变化 想要运行 gulp 文件，需要下载 gulp 提供的另一个模块 之后使用执行任务，gulp 会自动寻找 gulpfile.js 文件中的 first 任务并执行 Gulp插件 gulp-htmlmin ：html文件压缩 gulp-csso ：压缩css gulp-babel ：JavaScript语法转化 gulp-less: less语法转化 gulp-uglify ：压缩混淆JavaScript gulp-file-include： 公共文件包含 browsersync： 浏览器实时同步 实例 ::: details ::: Node.js 文件结构node_modules 文件夹及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢 复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错 在 node_modules 文件中存储的是当前项目的各项依赖，这个文件会十分复杂碎片且庞大。 package.json 项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。 在项目根目录下使用 npm init 命令生成，使用 npm init -y 快速生成，无需填写相关信息 当项目中存在 package.json 文件后，每次 install 第三方模块都会记录到dependencies 字段中 需要注意的是如果你使用 cnpm 命令下载，是不会构建到 dependencies 中去的。 别人可以根据 package.json 获取你当前项目的依赖，npm install 会自动根据 package.json 文件下载相关依赖。 项目依赖 在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖 使用 npm install 包名 命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中 开发依赖 在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖 使用 npm install 包名 --save-dev 命令将包添加到 package.json 文件的 devDependencies 字段中 开发环境：使用 npm install 下载全部依赖 生产环境：使用 npm install --production 不下载开发环境依赖 package-lock.json 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 scripts命令别名，当命令行命令过长或复杂时，可以为将其键入 scripts 中，并赋予简单的别名，之后便可以提高 npm run 别名 执行这段命令。 Node.js 模块加载机制模块查找规则 require方法根据模块路径查找模块，如果是完整路径，直接引入模块。 如果模块后缀省略，先找同名JS文件再找同名JS文件夹 如果找到了同名文件夹，找文件夹中的index.js 如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到 无路径无后缀 Node.js 会假设它是系统模块 Node.js 会去 node_modulcs 文件中去查找 查找同名 js 文件 查找同名文件夹下的 index.js 查看文件夹的 package.json 的 main 选项，并去文件查找 如果仍未找到，报错 Node.js 全局对象在浏览器中全局对象是window，在node中全局对象是global node全局对象中有以下方法，可以在任何地方使用，global可以省略 console.log() ：控制台输出 setTimeout() ： 设置超时定时器 cleartimeout()：清除超时定时器 setInterval() ：设置间歇定时器 clearInterval() ：清除间歇定时器 "},{"title":"JavaScipt高级（五）ES6","date":"2020-08-22T16:00:00.000Z","url":"/blog/2020/08/23/FontEnd-2020-8-Js-senior-5/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 前言ECMAScript 6ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言 ECMAScript和JavaScript的关系一个常见的问题是，ECMAScript和JavaScript到底是什么关系？ 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。 该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。 ES6与ECMAScript 2015的关系媒体里面经常可以看到”ECMAScript 2015“这个词，它与ES6是什么关系呢？ 2011年，ECMAScript 5.1版发布后，就开始制定6.0版了。因此，”ES6”这个词的原意，就是指JavaScript语言的下一个版本。 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布6.0版，过一段时间再发6.1版，然后是6.2版、6.3版等等。 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 标准委员会最终决定，标准在每年的6月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的6月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ES6的第一个版本，就这样在2015年6月发布了，正式名称就是《ECMAScript 2015标准》（简称ES2015）。2016年6月，小幅修订的《ECMAScript 2016标准》（简称ES2016）如期发布，这个版本可以看作是ES6.1版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017年6月将发布ES2017标准。 因此，ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。本书中提到“ES6”的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。 为什么使用 ES6每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。 变量提升特性增加了程序运行时的不可预测性 语法过于松散，实现相同的功能，不同的人可能会写出不同的代码 ES6 新增语法letES6中新增了用于声明变量的关键字。 let 声明的变量只在所处于的块级有效 {} 花括号代表块级作用域 使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。 防止循环变量污染 不存在变量提升 暂时性死区 利用let声明的变量会绑定在这个块级作用域，不会受外界的影响 经典实例 此例的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。 此例的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值。 const声明常量，常量就是值（内存地址）不能变化的量 具有块级作用域 声明常量时必须赋值 常量赋值后，地址不能修改 var let const 区别 var let const 函数级作用域 块级作用域 块级作用域 变量提升 不存在变量提升 不存在变量提升 值可更改 值可更改 值不可更改 灵活使用 var let const 能有效提高程序效率。 解构赋值ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构 数组解构 对象解构 箭头函数ES6中新增的定义函数的方式。 实例： 如果函数体内只有一句代码，切代码执行结果就是返回值，可以省略花括号 如果形参只有一个，可以省略小括号 箭头函数中的this 箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this。 经典面试 rest …剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数 在 Function 对象中的 arguments 属性虽然是数组，但是其没有数组的 pop push 等方法。 在箭头函数中没有 arguments 属性。 剩余参数与解构 ES6 内置对象扩展Array 扩展方法扩展运算符（展开语法） 扩展运算符可以将数组或者对象转为用逗号分隔的参数序列 扩展运算符可以应用于合并数组 将类数组或可遍历对象转换为真正的数组 构造函数方法 Array.from() 将伪数组或可遍历对象转换为真正的数组 实例方法 find() 用于找出第一个符合条件的数组成员，如果没有找到返回undefined 实例方法 findIndex() 用于找出第一个符合条件的数组成员的位置，如果没有找到返回 -1 实例方法 includes() 判断某个数组是否包含给定的值，返回布尔值。 String 扩展方法模板字符串 ES6新增的创建字符串的方式，使用反引号定义 模板字符串中可以使用 $&#123;&#125; 解析变量 模板字符串中可以换行 在模板字符串中调用函数，在函数位置会显示函数返回值 实例方法 startsWith() 和 endsWith() startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值 endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值 实例方法 repeat() repeat方法表示将原字符串重复n次，返回一个新字符串 Set 数据结构ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构 Set函数可以接受一个数组作为参数，用来初始化。 Set 是以 Object 形式进行存储的 参数为数组时会自动过滤数组中的重复元素 应用场景：搜索历史存储 利用 Set 对数组去重 操作数据 add() : 添加某个值，返回 Set 结构本身 delete() ： 删除某个值，返回一个布尔值，表示删除是否成功 has() : 返回一个布尔值，是否存在 Set 成员 clear() ：清除所有成员，没有返回值 实例： 遍历 Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 "},{"title":"JavaScipt高级（四）正则表达式","date":"2020-08-21T16:00:00.000Z","url":"/blog/2020/08/22/FontEnd-2020-8-Js-senior-4/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。 正则表达式概述正则表达式初识正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。 正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。 正则表达式特定 灵活性、逻辑性和功能性非常的强。 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。比如：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. 比如用户名: /^[a-z0-9_-]&#123;3,16&#125;$/ Js中的正则表达式创建在 JavaScript 中，可以通过两种方式创建一个正则表达式。 方式一：通过调用 RegExp 对象的构造函数创建 方式二：利用字面量创建 正则表达式 测试test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false ，其参数是测试字符串。 regexObj ： 正则对象 str ：测试字符串 正则表达式语法语法结构一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。 特殊字符非常多，可以参考： MDN jQuery 手册：正则表达式部分 正则测试工具 个人推荐快速入门Guide: ziishaned/learn-regex 元字符正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍： 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的在*号之前的字符。 + 匹配&gt;=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. | 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \\ ^ 从开始行开始匹配. $ 从末端开始匹配. 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） 如果 ^和 $ 在一起，表示必须是精确匹配。 字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。 []方括号 表示有一系列字符可供选择，只要匹配其中一个就可以了 ::: details ::: 转义字符 反斜线 \\ 取反操作 量词符 量词符用来设定某个模式出现的次数。 量词 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 预定义类正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p&#123;Z&#125;] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 修饰符 switch 可选，按照什么样的模式来匹配 g : 全局匹配 i : 忽略大小写 gi : 全局匹配 + 忽略大小写 实例 匹配行为如同 test() 方法，可以返回是否匹配的布尔值，存在另外的匹配行为。 校验 test 替换 replace replace() 是 String 下的方法。 实例 在线工具菜鸟在线工具 regex101 案例用户表单验证功能需求: 如果用户名输入合法, 则后面提示信息为: 用户名合法,并且颜色为绿色 如果用户名输入不合法, 则后面提示信息为: 用户名不符合规范, 并且颜色为红色 分析: 用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为6~16位. 首先准备好这种正则表达式模式/$[a-zA-Z0-9-_]{6,16}^/ 当表单失去焦点就开始验证. 如果符合正则规范, 则让后面的span标签添加 right类. 如果不符合正则规范, 则让后面的span标签添加 wrong类. 源码: ::: details ::: 验证座机号码 邮箱验证 敏感词过滤"},{"title":"JavaScipt高级（三）函数进阶","date":"2020-08-21T16:00:00.000Z","url":"/blog/2020/08/22/FontEnd-2020-8-Js-senior-3/","tags":["JavaScript"],"categories":["FrontEnd"],"content":" 函数 this 严格模式 闭包 递归 函数函数定义 函数声明 function 关键字 （命名函数） 函数表达式 （匿名函数） new 关键字 (构造函数) Function 里面参数都必须是字符串格式 函数调用 函数内的this指向这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同，一般指向我们的调用者 调用方式 this 指向 普通函数调用 window 构造函数调用 实例对象 原型对象里面的方法也指向实例对象 对象方法调用 该方法所属对象 事件绑定方法 绑定事件对象 定时器函数 window 立即执行函数 window 改变函数this指向call()call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向 应用场景：继承 apply()apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。 应用场景：数组 bind()bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind call、apply、bind三者的异同 共同点 : 都可以改变this指向 不同点: call 和 apply 会调用函数, 并且改变函数内部this指向. call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递 bind 不会调用函数, 可以改变函数内部this指向. 应用场景 call 经常做继承. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 严格模式JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。 严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。 严格模式对正常的 JavaScript 语义做了一些更改： 消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。 消除代码运行的一些不安全之处，保证代码运行的安全。 提高编译器效率，增加运行速度。 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名 开启严格模式严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为 脚本开启严格模式 和为 函数开启严格模式 两种情况。 脚本开启严格模式 为函数开启严格模式 严格模式规范变量规定 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种做法，变量必须先声明再使用 不允许使用 delete 关键字删除变量 全局声明函数（包括构造函数）中的 this 不再指向 window 而是 undefined 定时器函数内指向仍是 window , 对于构造函数，this 仍指向实例对象（类名调用除外） 不允许函数参数同名 不允许在非函数的代码块内声明函数 高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。 函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。 同理函数也可以作为返回值传递回来 闭包变量作用域变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以使用全局变量。 函数外部不可以使用局部变量。 当函数执行完毕，本作用域内的局部变量会销毁。 闭包定义闭包（closure）指有权访问另一个函数作用域中变量的函数。 —–《JavaScript高级程序设计》 简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 通过浏览器的断点调试中 Scope 属性我们能够清除看见当前函数是否闭包。 闭包的作用 延伸变量的作用范围。 防止变量环境污染。 利于模块化设计和方法封装 闭包案例1. 循环注册点击事件 2. 3秒钟之后,打印所有li元素的内容 **3. 计算打车价格 **打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费 经典实例 递归递归定义递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数 注意：递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。 阶乘 斐波那契数列 遍历 递归遍历与DFS(深度优先遍历效果一致) 深浅拷贝浅拷贝只会拷贝一层，更深层次的对象只会引用地址 深拷贝拷贝多层，所有数据都会创建新内存空间 "},{"title":"JavaScipt高级（二）构造函数和原型","date":"2020-08-20T16:00:00.000Z","url":"/blog/2020/08/21/FontEnd-2020-8-Js-senior-2/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"在典型的 OOP 语言中 （如 Java ），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6 之前 javascript 并没有引入类的概念。 ES6 ，全称 ECMAScript6.0，于2015.6 发布。但是目前浏览器的 javascript 是 ES5 版本，大多数高版本浏览器也支持 ES6 ，不过只实现了 ES6 部分特性和功能 在 ES6 之前，对象不是基于类创建的，而是使用一种称为构造函数的特殊函数来定义对象。 构造函数和原型创建对象的三种方式 字面量方式 new关键字 构造函数方式 实例成员和静态成员实例成员 实例成员就是构造函数内部通过 this 添加的成员，如下列代码中的 uname , age , sing 就是实例成员，实例成员只能通过实例化的对象来访问。 静态成员 静态成员 在构造函数本身上添加的成员 如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问 构造函数的问题构造函数方法虽然好用，但是存在内存浪费问题 在以上代码片段的构造函数 Start 中，sing 为复杂数据类型，两个实例对象开辟了两个内存空间，来存放同一个函数方法。 构造函数原型 prototype构造函数通过原型分配的函数是所有对象所共享的。 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 对象原型 __proto__对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。__proto__ 对象原型和原型对象 prototype 是等价的__proto__ 对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype 构造函数 constructor对象原型 __proto__ 和构造函数 prototype 原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。 constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。 一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 构造函数 实例 原型对象三角关系 原型链每一个实例对象又有一个 __proto__ 属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有 __proto__ 属性，这样一层一层往上找就形成了原型链。 根据上图，我们可以建立庞大复杂的对象模型，请严格遵守链式调用规则，比如我需要访问 ldh 实例对象 的构造函数时，遵循原型链，其语法应该为： 成员查找机制 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型 如果还没有就查找原型对象的原型（Object的原型对象）。 依此类推一直找到 Object 为止（null）。 __proto__ 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。 原型对象中的this指向构造函数中的this和原型对象的this,都指向我们new出来的实例对象。 扩展内置对象通过对象原型，对原来的内置对象进行扩展自定义方法。比如，我们为内置对象 Array 扩展一个求数组总和的方法 sum() 组合继承在 ES6 之前，并没有 extends 关键字，我们只能通过构造函数+原型对象模拟实现继承，被称为组合继承 call() 方法call() 可以调用函数 call() 可以修改 this 的指向,使用 call() 的时候 参数一是修改后的 this 指向,参数2,参数3..使用逗号隔开连接 构造函数继承属性通过 call() 关键字，修改父构造函数的 this 指向为 子构造函数的实例。 &#123;11&#125; 以上实例 Son 构造函数继承了父亲 Father 的 uname 和 age 属性。 原型对象继承方法 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) ES5 新增方法数组方法迭代（遍历）数组：forEach() , map() , filter() , some() , every() forEach() 该方法会遍历当前数组，并提供一个带参数的回调函数。 map() map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 filter() filter() 方法会遍历当前数组，并为每个元素执行函数，返回新的数组。 some() some() 方法用于查找当前数组中元素是否满足条件，其返回一个布尔值，查找到返回 true , 否则 false。如果查找到第一个符号条件，跳出循环。 every() every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 筛选商品案例 ::: details ::: 字符串方法trim() trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。 对象方法Object.keys() Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。 Object.defineProperty() Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 语法 参数 obj 要定义属性的对象。 prop 要定义或修改的属性的名称或 Symbol。 descriptor 要定义或修改的属性描述符。 返回值 被传递给函数的对象。"},{"title":"JQuery 入门（三）","date":"2020-08-19T16:00:00.000Z","url":"/blog/2020/08/20/FontEnd-2020-8-JQuery-Start-3/","tags":["JavaScript","JQuery"],"categories":["FrontEnd"],"content":" JQuery 事件注册 JQuery 事件处理 JQuery 事件对象 JQuery 事件注册jQuery 为我们提供了方便的事件注册机制，优缺点如下： 优点: 操作简单，且不用担心事件覆盖等问题。 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。 语法 事件类型和原生js基本一致 mouseover , mouseout , blur , focus , keydown , resize … JQuery 事件处理因为普通注册事件方法的不足，jQuery又开发了多个处理方法 ： on(): 用于事件绑定，目前最好用的事件绑定方法 off(): 事件解绑 trigger() / triggerHandler(): 事件触发 事件绑定因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法 bind() / live() / delegate() / on() 等，其中最好用的是: on() 事件解绑当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one() ，在这里我们重点讲解一下 off() ; off() 自定触发事件有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; trigger() triggerHandler() triggerHandler() 不会触发元素的默认行为，如输入框获取焦点后，光标闪烁。 JQuery 事件对象jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。 阻止默认行为：e.preventDefault() 阻止冒泡：e.stopPropagation() JQuery 拷贝对象如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用 $.extend() 方法 $.extend() deep ：拷贝深浅，默认浅拷贝 浅拷贝目标对象引用被拷贝对象的地址，修改目标对象会影响被拷贝对象，对象嵌套 深拷贝完全克隆一份对象，修改目标对象不会影响被拷贝对象，对象嵌套 target ：需要拷贝的对象 object ：待拷贝对象 objectN ：复数拷贝 JQuery 多库共存实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。 可能存在这样的情况，其他 js 库或函数使用了 $ 符作为函数封装，这样就会与 JQuery 产生冲突，JQuery 为我们提供了解决方案 使用 JQuery() 替代 $() JQuery 释放 $ 符控制权：var Pick = $.noConfilict() ，这样我们就可以使用 Pick() JQuery 插件jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于 jQuery 来完成的，所以必须要先引入 jQuery 文件，因此也称为 jQuery 插件。 jQuery 插件常用的网站： JQuery插件库 JQuery之家 综合案例 toDoList需求 文本框里面输入内容，按下回车，就可以生成待办事项。 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。 页面刷新内容不会丢失。 分析 刷新页面不会丢失数据，因此需要用到本地存储 localStorage 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据 存储的数据格式：var todolist = [&#123; title : ‘xxx’, done: false&#125;] 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式 JSON.parse() 我们才能使用里面的数据。 功能实现 新添todo 切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。 利用事件对象 .keyCode 判断用户按下回车键（13）。 声明一个数组，保存数据。 先要读取本地存储原来的数据（声明函数 getData() ），放到这个数组里面。 之后把最新从表单获取过来的数据，追加到数组里面。 最后把数组存储给本地存储 (声明函数 savaDate() ) 加载todo 因为后面也会经常渲染加载操作，所以声明一个函数 load ，方便后面调用 先要读取本地存储数据。（数据不要忘记转换为对象格式） 之后遍历这个数据（ $.each() ），有几条数据，就生成几个小 li 添加到 ol 里面 每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据 删除todo 点击里面的a链接，不是删除的 li ，而是删除本地存储对应的数据。 先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li 我们可以给链接自定义属性记录当前的索引号 根据这个索引号删除相关的数据—-数组的 splice(i, 1) 方法 存储修改后的数据，然后存储给本地存储 重新渲染加载数据列表 因为a是动态创建的，我们使用 on() 绑定事件 完成todo 当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。 点击之后，获取本地存储数据。 修改对应数据属性 done 为当前复选框的 checked 状态。 之后保存数据到本地存储 重新渲染加载数据列表 load 加载函数里面，新增一个条件,如果当前数据的 done 为 true 就是已经完成的，就把列表渲染加载到 ul 里面 如果当前数据的 done 为 false ， 则是待办事项，就把列表渲染加载到 ol 里面 统计todo 在我们 load 函数里面操作 声明2个变量 ：todoCount 待办个数 doneCount 已完成个数 当进行遍历本地存储数据的时候， 如果 数据 done 为 false ， 则 todoCount++ , 否则 doneCount++ 最后修改相应的元素 text() "},{"title":"JavaScipt高级（一）面向对象","date":"2020-08-19T16:00:00.000Z","url":"/blog/2020/08/20/FontEnd-2020-8-Js-senior-1/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"面向对象 OOP (Object Oriented Programming) 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 典型语言：c++ java c# 面向对象的特性： 封装性 继承性 多态性 编程思想面向过程 POP (Process-oriented programming) 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。 典型语言：c pascal 面向对象 OOP (Object Oriented Programming) 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 典型语言：c++ java c# 面向对象的特性： 封装性 继承性 多态性 对比 面向过程 面向对象 优点 性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点 不易维护、不易复用、不易扩展 性能比面向过程低 对象与类 ES6对象对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 创建对象 类在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。 创建类 实例化类 添加属性和方法 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 多个函数方法之间不需要添加逗号分隔 生成实例 new 不能省略 类的继承通过 extends 关键字可以使子类继承父类的属性和方法 语法 super 关键字 子类可以用 super() 方法访问父类的方法 继承中，如果实例化子类输出一个方法，先看子类有没有这个方法。如果有就先执行子类的 继承中，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法 (就近原则) 如果子类想要继承父类的方法，同时在自己内部扩展自己的方法，利用super 调用父类的构造函数，super 必须在子类this之前调用 时刻注意 this 的指向问题，类里面的共有的属性和方法一定要加 this 使用. constructor 中的 this 指向的是 new 出来的实例对象 自定义的方法，一般也指向的 new 出来的实例对象 绑定事件之后 this 指向的就是触发事件的事件源 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 面向对象 Tab切换栏需求 点击 tab栏,可以切换效果. 点击 + 号, 可以添加 tab 项和内容项. 点击 x 号, 可以删除当前的 tab 项和内容项. 双击 tab 项文字或者内容项文字可以修改里面的文字内容 准备 获取到标题元素 获取到内容元素 获取到删除的小按钮 x号 新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改) 时刻注意this的指向问题 切换为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引 使用排他,实现只有一个元素的显示 添加为添加按钮+ 绑定点击事件 实现标题与内容的添加,做好排他处理 删除为元素的删除按钮x绑定点击事件 获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容 编辑为元素(标题与内容)绑定双击事件 在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递 "},{"title":"JQuery 入门（二）","date":"2020-08-17T16:00:00.000Z","url":"/blog/2020/08/18/FontEnd-2020-8-JQuery-Start-2/","tags":["JavaScript","JQuery"],"categories":["FrontEnd"],"content":" JQuery 属性操作 JQuery 文本内容 JQuery 节点操作 JQuery 尺寸位置 JQuery 属性操作jQuery 常用属性操作有三种 prop() attr() data() prop()固有属性操作 所谓元素固有属性就是元素本身自带的属性，比如 &lt;a&gt; 元素里面的 href ，比如 &lt;input&gt; 元素里面的 type。 语法 获取属性 设置属性 prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。 attr()自定义属性操作 用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 语法 获取属性 设置属性 attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性） data()数据缓存 data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 语法 附加数据 获取数据 JQuery 文本属性jQuery的文本属性值常见操作有三种：html() / text() / val() 分别对应JS中的 innerHTML innerText value 属性。 html() text() val()表单值操作 JQuery 节点操作jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。 遍历元素jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 语法1 function ：回调函数 index ：元素索引号 domEle ：DOM 元素对象 此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换 $(domEle) 。 语法2 $.each() 方法可以用于遍历任何对象。主要用于数据处理，比如数组，对象。 增删元素jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下： 创建 内部添加 父子添加 把内容放入匹配元素内部的最后面，类似原生 appendChild 把内容放入匹配元素最前面 外部添加 兄弟添加 删除元素 JQuery 尺寸操作jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。 语法 说明 width() / height() 取得匹配元素的宽高度 只算 width / height innerWidth() / innerHeight() 取得匹配元素的宽高度 包含 padding outerWidth() / outerHeight() 取得匹配元素的宽高度 包含 padding border outerWidth(true) / outerHeight(true) 取得匹配元素的宽高度 包含 padding border margin 有了这套 API 我们将可以快速获取盒子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合 JQuery 位置操作jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下: offset() 设置或返回被选元素相对于文档的偏移坐标，和父级无关 该方法有两个属性 left , top 。offset().top 用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。 设置元素偏移 ： offset(&#123;top:10,left:10&#125;) position() 返回被选元素相对于带有定位的父级偏移坐标，如果父级没有定位，这相对于文档。 该方法有两个属性值 left top 该方法只能获取 scrollTop() / scrollLeft() 设置或返回被选元素被卷去的头部 设置 scrollTop(100) "},{"title":"JavaScript基础（六）作用域","date":"2020-08-17T16:00:00.000Z","url":"/blog/2020/08/18/FontEnd-2020-8-Js-Start-6-Scope/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"JavaScript（ES6前）中的作用域有两种： 全局作用域 局部作用域（函数作用域） 作用域作用域概述通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 JavaScript（es6前）中的作用域有两种： 全局作用域 局部作用域（函数作用域） 全局作用域作用于所有代码执行的环境(整个script标签内部)或独立的js文件。 局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 块级作用域 块作用域由 { } 包括。 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码： 以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；而与之类似的JavaScript代码，则不会报错。 ES6之后新增块级作用域 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种： 全局变量 局部变量 全局变量在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用） 在函数体外使用var关键字声明的变量和在函数体内未使用任何关键字声明的变量是全局变量 局部变量在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）。 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 在函数体内使用var关键字声明的变量是局部变量 区别全局变量和局部变量的区别 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间 作用域链只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。 示例1：内部函数访问外部函数变量 示例2：就近原则 预解析JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。 JavaScript 解析器在运行 JavaScript 代码的时候分为两步： ​ 预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。 代码执行： 从上到下执行JS语句。 注意：预解析会把变量和函数的声明在代码执行之前执行完成。 变量预解析变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。 注意：只提升声明，不提升赋值 函数预解析函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用，上面的代码是我们为演示自己进行了调用！ 函数表达式问题函数表达式创建函数，会执行变量提升。 解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用 快速理解实例实例一 其相当于以下代码片段 实例二 其相当于以下代码片段 实例三 其相当于以下代码片段 实例四 其相当于以下代码片段 "},{"title":"JavaScript基础（七）对象","date":"2020-08-17T16:00:00.000Z","url":"/blog/2020/08/18/FontEnd-2020-8-Js-Start-7-Object/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 创建对象 操作对象 内置对象 对象概念什么是对象？ ​ 在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的： 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 为什么需要对象？ ​ 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。如果要保存一个人的完整信息呢？例如，将“张三疯”的个人的信息保存在数组中的方式为： ​ 上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。 ​ 为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。 使用对象记录上组数据为： JS中的对象表达结构更清晰，更强大。 创建对象字面量创建花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 访问对象的属性 调用对象方法 区分变量，属性，函数，方法 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明；方法是对象的一部分，函数是单独封装操作的容器 函数：单独存在的，通过“函数名()”的方式就可以调用 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用 new Object创建空对象 通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象 给空对象添加属性和方法 通过对象操作属性和方法的方式，来为对象增加属性和方法 构造函数对象构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 构造函数的调用格式 注意事项 构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 new关键字的作用 在构造函数代码开始执行之前，创建一个空对象； 修改this的指向，把this指向创建出来的空对象； 执行函数的代码 在函数完成之后，返回this—即创建出来的对象 这个构造函数可以泛理解为 类 class ，创建对象时的 new 可以理解为对象实例化。 遍历对象 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 内置对象JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象​ 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发 JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。 Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 MDN Doc MathMath 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()/Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 获取指定范围内的随机整数： DateDate 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 实例化： 获取指定时间的日期对象: 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 方法名 说明 getFullYear() 获取年 getMonth() 获取月（0-11） getDate() 获取天 getDay() 获取星期（0-6） getHours() 获取小时 getMinutes() 获取分钟 getSeconds() 获取秒 通过Date实例获取总毫米数 Array 方法 说明 返回值 Array.isArray() 判断是否是数组 true false push() 末尾添加一个或多个元素 返回新长度 pop() 删除最后一个元素 返回删除元素 unshift() 首项插入一个或多个元素 返回新长度 shift() 删除首元素 返回删除元素 reverse() 颠倒顺序 返回新数组 sort() 升序参数： function(a,b)&#123; return a-b;&#125; 降序参数：function(a,b)&#123; return b-a;&#125; 返回新数组 indexOf() 查找参数的第一个索引 返回索引号，无则 -1 lastIndexOf() 查找参数的最后一个索引 返回索引号，无则 -1 toString() 把数组转换成字符串，逗号分隔 返回字符串 join(&#39;分隔符&#39;); 把数组转换成字符串，分隔符分隔 返回字符串 concat() 连接两个或多个数组，不影响原数组 返回新数组 slice(begin,end) 数组截取 返回截取新数组 splice(index,num) 删除数组 修改原数组 返回被删除数组。 instanceof 运算符 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。 数组去重案例 String为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 字符串的不可变性 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。​ 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 方法 说明 indexOf(&#39;str&#39;,index) 从index开始查找str字符并访问索引号，找不到 -1 lastIndex() 从后往前找，只找第一个匹配的 charAt(index) 返回指定索引号的字符 charCodeAt(index) 获取指定索引号的ASCII码 str[index] 获取指定位置处字符 concat(str1,str2...) 拼接字符串 substr(start,length) 从start开始截取 length 个长度 slice(start,end) 从start开始，截取到end位置 substring(start,end) 从start开始，截取到end位置 不接受负值 replace(str,newstr) 将str替换成 newstr 只替换匹配到的第一个 split() 将字符串中的匹配参数分割 返回新数组 案例：求一个字符串中出现最多的字符和其出现次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 "},{"title":"JavaScript基础（八）内存","date":"2020-08-17T16:00:00.000Z","url":"/blog/2020/08/18/FontEnd-2020-8-Js-Start-8-Memory/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"简单数据类型的存储方式 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 数据类型深入简单数据类型简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括 string ，number，boolean，undefined，null 复杂数据类型复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 堆栈注意：JavaScript 并不存在堆栈，这里只是形象说明 堆栈空间分配区别： 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 简单类型传参函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 复杂类型传参函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 运行结果： "},{"title":"JQuery 入门（一）","date":"2020-08-16T16:00:00.000Z","url":"/blog/2020/08/17/FontEnd-2020-8-JQuery-Start-1/","tags":["JavaScript","JQuery"],"categories":["FrontEnd"],"content":" jQuery 是一个快速、简洁的 JavaScript 库，其对原生 JavaScript 中的一些方法进行了封装和扩展。 write less, do more. JQuery 介绍JavaScript 库JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。 JQuery 概念 jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是 JavaScript； Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。 jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。 学习jQuery本质： 就是学习调用这些函数（方法）。 jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 JQuery 优点 轻量级。核心文件才几十kb，不会影响页面加载速度。 跨浏览器兼容，基本兼容了现在主流的浏览器。 链式编程、隐式迭代。 对事件、样式、动画支持，大大简化了DOM操作。 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。 免费、开源。 JQuery 开始JQuery 下载官方文档 下载地址 本地依赖 下载 jquery.min.js 到项目目录，并在 head 引入 在线CDN JQuery 体验 JQuery 入口函数jQuery中常见的两种入口函数： 以上两种方式都是当 DOM 加载完成后执行，相当于原生 Js 的 DOMContentLoaded ，注意与 onload 区分。 JQuery 顶级对象 $ $是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。 $是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。 JQuery 对象使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : 用原生 JS 获取来的对象就是 DOM 对象 jQuery 方法获取的元素就是 jQuery 对象 jQuery 对象本质是： 利用$对 DOM 对象包装后产生的对象（伪数组形式存储）。 对象转换DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。 JQuery 选择器原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 更多选择器请参考 官方文档 基础选择器 名称 用法 描述 ID选择器 $(&quot;#id&quot;) 获取指定ID元素 全选择器 `$(“*”) 匹配所有元素 类选择器 $(“.class”) 获取class类 标签选择器 $(“element”) 获取标签 并集选择器 $(“selector1,selector2”) 多个元素 交集选择器 $(“selector1.selector2”) 交集元素 层级选择器 名称 用法 描述 子代选择器 $(&quot;ul&gt;li&quot;) 获取亲儿子层级元素 后代选择器 $(&quot;ul li&quot;) 获取子孙后代元素 筛选选择器 语法 用法 描述 :first $(&quot;li:first&quot;) 获取第一个 li 元素 :last $(&quot;li:last&quot;) 获取最后一个 li 元素 :eq(index) $(&quot;li:eq(2)&quot;) 获取 index 个 li 元素 :odd $(&quot;li:odd&quot;) 获取偶数 li :even $(&quot;li:even&quot;) 获取奇数 li 筛选方法 语法 用法 说明 parent() $(&quot;li&quot;).parent() 查找父级 children(selector) $(&quot;ul&quot;).children(&quot;li&quot;) 查找亲子级 find(selector) $(&quot;ul&quot;).find(&quot;li&quot;) 查找后代 siblings(selector) $(&quot;.first&quot;).siblings(&quot;li&quot;) 查找兄弟节点，不包括自己 nextAll([expr]) $(&quot;.first&quot;).nextAll() 查找当前元素之后的所有同级元素 prevAll([expr]) $(&quot;.first&quot;).prevAll() 查找当前元素之前的所有同级元素 hasClass(calss) $(&quot;div&quot;).hasClass(&quot;protected&quot;) 检查当前元素是否包含某个特定类，返回 true 或 false eq(index) $(&quot;li&quot;).eq(2) 查找第index个元素 JQuery 隐式迭代在原生JS中，我们如果需要为一组元素添加事件或设置样式需要使用 for 循环遍历这组元素。而在 JQuery 中，我们不再需要循环遍历了，JQuery 会为我们隐式迭代这组元素，为这组元素都添加你设置的事件或样式。 JQuery 样式操作JQuery 操作样式有两种方式，一种是通过 css() 方法，另一种是通过类操作。 css() 方法 css() 应用于少量样式操作时，如果样式过多请通过添加类操作。 class() 方法 设置类样式方法比较适合样式多时操作，可以弥补css()的不足。 原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。 JQuery 动画​ jQuery 给我们封装了很多动画效果，最为常见的如下： 显示隐藏：show() , hide() , toggle() 划入画出：slideDown() , slideUp() , slideToggle() 淡入淡出：fadeIn() , fadeOut() , fadeToggle() , fadeTo() 自定义动画：animate() 注意： 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 jQuery为我们提供另一个方法，可以停止动画排队：stop() ; 显示隐藏show() 参数 参数都可以省略，无动画直接显示 speed：可选，预设参数 slow,normal,fast，也可填写毫秒数 ms easing：动画函数，预设 swing , linear fn：回调函数 hide() toggle() 实例 ::: details ::: 滑入滑出slideDown() slideUp() slideToggle() 实例 ::: details ::: 淡入淡出fadeIn() fadeOut() fadeTo() 渐近方式调整不透明度 opacity : 必需，透明度 0~1 fadeToggle 实例 ::: details ::: 动画排队动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 停止动画排队的方法为：stop() stop() 方法用于停止动画或效果。 stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 总结: 每次使用动画之前，先调用 stop() ,在调用动画。 自定动画自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() 参数 params ：必需，想要更改的样式属性，以对象形式传递，复合属性使用驼峰命名。 实例 ::: details :::"},{"title":"JavaScript变量提升","date":"2020-08-15T16:00:00.000Z","url":"/blog/2020/08/16/FontEnd-2020-8-JavaScritpHoisting/","tags":["JavaScript"],"categories":["FrontEnd"],"content":" JavaScript 中，函数及变量的声明都将被提升到作用域的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 简单实例有以下两个实例： 你可能认为这是一段错误的 Js 代码，其调用了未声明的变量或函数。其实这两个实例等价于： 变量提升要理解以上实例就需要理解 **”hoisting(变量提升)”**。 变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。 需要注意的是初始化的变量其初始化的值不会进行提升。 上面代码片段的 y 输出了 undefined，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。 参考资料：菜鸟教程 JavaScript变量提升 深入以上是参考菜鸟教程的简单说明，接下来我们将进一步理解变量/函数提升 执行原理JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。 JavaScript 解析器在运行 JavaScript 代码的时候分为两步： ​ 预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。 代码执行： 从上到下执行JS语句。 注意：预解析会把变量和函数的声明在代码执行之前执行完成。 变量预解析变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。 注意：只提升声明，不提升赋值 函数预解析函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用，上面的代码是我们为演示自己进行了调用！ 局部提升所有的提升都是提升到当前作用域的顶部，全局变量提升到全局 window 下，局部变量提升到当前函数顶端。 我们姑且称全局变量的提升为全局提升，局部变量在函数体内的提升为局部提升。 函数表达式型的函数会以变量提升的形式进行提升 经典实例以下几个实例可以让你快速理解 JavaScript 的变量/函数提升，也是面试试题。 实例一 其相当于以下代码片段 运行结果 实例二 其相当于以下代码片段 运行结果 实例三 其相当于以下代码片段 运行结果 实例四 其相当于以下代码片段 运行结果 总结JavaScript 中，函数及变量的声明都将被提升到作用域的最顶部。 虽然从代码上看，是未进行声明直接调用，其实解析器已经将声明体提升到其作用域前。 个人见解，与其说变量提升是一种特性，不如说是 javascript 的语法缺陷，在 ES5 的严格模式中，不再允许变量未声明赋值调用。"},{"title":"JavaScript基础（二）运算符","date":"2020-08-15T16:00:00.000Z","url":"/blog/2020/08/16/FontEnd-2020-8-Js-Start-2-Operator/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"运算符的分类运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。 JavaScript中常用的运算符有： 算数运算符 递增和递减运算符 比较运算符 逻辑运算符 赋值运算符 算数运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取余 浮点数的精度问题 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。 所以：不要直接判断两个浮点数是否相等 ! 表达式和返回值 表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合 简单理解：是由数字、运算符、变量等组成的式子 表达式最终都会有一个结果，返回给开发者，称为返回值 递增递减运算符 递增和递减运算符概述 如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ – ）运算符来完成。 递增运算符 前置递增运算符 后置递增运算符 递减同形 区别 前置：先自算，再返回运算结果给表达式 前置：先表达式返回原值，再自算 比较运算符 运算符 说明 &lt; 小于 &gt; 大于 &gt;= 大于等于 &lt;= 小于等于 == 判断等 != 不等 === !== 全等 逻辑运算符 逻辑运算符 说明 &amp;&amp; 与 ` ! 非 短路特性（逻辑中断） 短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值; &amp;&amp; || 赋值运算符 赋值运算符 说明 = 直接赋值 += , -= 加，减一个数后再赋值 *= , /= , %= 乘，除，取模一个数后再赋值 运算符优先级 优先级 运算符 顺序 1 小括号 () 2 一元运算符 ++ -- ! 3 算数运算符 先 * / % 后 + - 4 关系运算符 &gt; &gt;= &lt; &lt;= 5 相等运算符 == != === !== 6 逻辑运算符 `先 &amp;&amp; 后 7 赋值运算符 = 8 逗号运算符 , 一元运算符里面的逻辑非优先级很高 逻辑与 比 逻辑或 优先级高 条件语句 if if else ? : ; switch "},{"title":"JavaScript基础（三）循环","date":"2020-08-15T16:00:00.000Z","url":"/blog/2020/08/16/FontEnd-2020-8-Js-Start-3-Cycle/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"循环for 循环 名称 作用 初始化变量 通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。 条件表达式 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。 操作表达式 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程 断点调试的流程： 浏览器中按 F12–&gt; sources –&gt;找到需要调试的文件–&gt;在程序的某一行设置断点 Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。 摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。 循环嵌套循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。 内层循环可以看做外层循环的循环体语句 内层循环执行的顺序也要遵循 for 循环的执行顺序 外层循环执行一次，内层循环要执行全部次数 while 循环 注意： 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环 do while 循环 循环操作 continue continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。 break break 关键字用于立即跳出整个循环（循环结束）。 代码规范标识符命名规范 变量、函数的命名必须要有意义 变量的名称一般用名词 函数的名称一般用动词 操作符规范 其他规范关键词、操作符之间后加空格 "},{"title":"JavaScript基础（四）数组","date":"2020-08-15T16:00:00.000Z","url":"/blog/2020/08/16/FontEnd-2020-8-Js-Start-4-Array/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"数组的概念 数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。 创建数组JS 中创建数组有两种方式： 利用 new 创建数组 利用数组字面量创建数组 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 这种字面量方式也是我们以后最多使用的方式 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 数组索引索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。 数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined 遍历数组把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项。 数组长度 数组的长度：默认情况下表示数组中元素的个数，使用 数组名.length可以访问数组元素的数量（数组长度）。 数组的length属性可以被修改 如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素 如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除 新增元素数组中可以通过以下方式在数组的末尾插入新元素： 通过将元素长度设置为索引号，新增元素。如果索引号已存在元素，会修改该元素。 冒泡排序源码"},{"title":"JavaScript基础（五）函数","date":"2020-08-15T16:00:00.000Z","url":"/blog/2020/08/16/FontEnd-2020-8-Js-Start-5-Function/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"函数的概念在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 函数的使用声明函数 function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 调用函数 调用的时候千万不要忘记添加小括号 声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 函数封装函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 函数的参数 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。 调用的时候实参值是传递给形参的 形参简单理解为：不用声明的变量 实参和形参的多个参数之间用逗号（,）分隔 函数形参和实参数量不匹配时 实参等于形参 输出正确结果 实参个数多余形参个数 只取到形参个数 实参个数小于形参个数 多的形参定义为 Undefined ，结果为 NaN 函数的返回值return 返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break , continue , return 的区别： break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 arguments 的使用当不确定有多少个参数传递的时候，可以用 arguments 来获取。 JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。 伪数组具有以下特点： 具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法 函数复调函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。 函数的两种声明方式命名函数利用函数关键字 function 自定义函数方式 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 详见：JavaScript 变量提升 匿名函数利用函数表达式，可以将函数匿名。 "},{"title":"JavaScript基础（一）变量","date":"2020-08-15T16:00:00.000Z","url":"/blog/2020/08/16/FontEnd-2020-8-Js-Start-1-Variable/","tags":["JavaScript"],"categories":["FrontEnd"],"content":"编程语言编程 编程： 就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 计算机程序： 就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令。 计算机语言 计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介。 计算机语言的种类非常的多，总的来说可以分成机器语言，汇编语言和高级语言三大类。 实际上计算机最终所执行的都是 机器语言，它是由“0”和“1”组成的二进制数，二进制是计算机语言的基础。 编程语言可以通过类似于人类语言的“语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming Language）。 编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。如今通用的编程语言有两种形式：汇编语言和高级语言。 语言类型 说明 汇编语言 汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。 高级语言 高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。 编译器高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。 标记语言 语言 说明 编程语言 编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的指令，这是主动的。 标记语言 标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的。 MarkDown 是比较常见和大量使用的标记语言，除此之外还有 BBcode 等等，这些语言多用于文档，记录，论坛，文章等场景 计算机基础计算机组成 数据存储 计算机内部使用二进制 0 和 1来表示数据。 所有数据，包括文件、图片等最终都是以二进制数据（0 和 1）的形式存放在硬盘中的。 所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘中。 硬盘、内存都是保存的二进制数据。 数据存储单位 位(bit)： 1bit 可以保存一个 0 或者 1 （最小的存储单位） 字节(Byte)：1B = 8b 千字节(KB)：1KB = 1024B 兆字节(MB)：1MB = 1024KB 吉字节(GB): 1GB = 1024MB 太字节(TB): 1TB = 1024GB 程序运行计算机运行软件的过程： 打开某个程序时，先从硬盘中把程序的代码加载到内存中 CPU执行内存中的代码 注意：之所以要内存的一个重要原因，是因为 cpu运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械） 初识 JavaScriptJs 历史 创始人布兰登*艾奇 （Brendan Eich，1961年~）用十天完成了 Javascript 的设计，最初命名为 LiveScript，后来与 Sun 合作重命名为 JavaScript。 JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思） 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 现在也可以基于 Node.js 技术进行服务器端编程 Js 作用 表单动态校验（密码强度检测） （ JS 产生最初的目的 ） 网页特效 服务端开发(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) html css js 关系 HTML 确定DOM树(内容数据) CSS 渲染HTML样式 JS 实现交互，业务逻辑 浏览器执行 Js 简介浏览器分为两部分 渲染引擎（内核）和 Js引擎 渲染引擎：解析 HTML 和 渲染CSS，如 Chrome 浏览器的 Blink Js引擎：Js解释器,用来读取和处理js代码，如 Chrome v8 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。 Js 组成 JavaScript ECMAScript DOM BOM ECMAScript ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。 ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 更多参看MDN: MDN手册 DOM 文档对象模型 文档对象模型（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等） BOM 浏览器对象模型 浏览器对象模型(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 Js 初始JS 有3种书写位置，分别为行内、内嵌和外部。 行内式 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick 注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号 可读性差， 在html中编写JS大量代码时，不方便阅读； 引号易错，引号多层嵌套匹配时，非常容易弄混； 特殊情况下使用 内嵌式 可以将多行JS代码写到 script 标签中 内嵌 JS 是学习时常用的方式 外部JS文件 利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用 引用外部 JS文件的 script 标签中间不可以写代码 适合于JS 代码量比较大的情况 JavaScript 注释和其他编程语言一样 Js 也提供了代码注释语法 单行注释 多行注释 JavaScript 交互为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下： 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。 JavaScript 变量变量定义变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。 变量存储变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。 变量使用变量声明 var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 变量赋值 = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思 变量值是程序员保存到变量空间里的值 变量初始化 扩展 更新变量 一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 同时声明多个变量 同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。 特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10; console.log (age); 不声明 只赋值 10 变量命名规范 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name 严格区分大小写。var app; 和 var App; 是两个变量 不能 以数字开头。 18age 是错误的 不能 是关键字、保留字。例如：var、for、while 变量名必须有意义。 MMD BBD nl → age 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName JavaScript 数据类型 为什么需要数据类型 ​ 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。 变量的数据类型 ​ 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定： 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： JavaScript 数据类型 简单数据类型 Number 数值 String 字符 Boolean 布尔 Undefined 未定义 Null 空 复杂数据类型 object 对象 Js 是一种弱类型或动态类型语言，因为其运行机制变量类型可以在程序运行时自动判断，不同于 C 和 Java 的语法严谨。 简单数据类型 Number 数字型 包含整型值浮点值，如 21，0.21 默认值：0 不同于其他语言对数字类型的细分如 C语言 int,float,double 等，JS 对数字细分类型并不敏感。 数字型进制 最常见的进制有二进制、八进制、十进制、十六进制。 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x 数字型范围 JavaScript中数值的最大和最小值 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32 特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 NaN ，Not a number ，代表一个非数值 isNaN() 用来判断一个变量是否为非数字的类型，返回 true 或者 false Boolean 布尔型 真假，true false，1，0 默认值：false 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 String 字符串型 如 ``”This is string”` 默认值： &quot;&quot; 字符串型可以是引号中的任意文本，其语法为 “双引号” 和 ‘单引号’ 因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。 引号嵌套 字符串转义 转义符 解释说明 \\n 换行符，n 是 newline 的意思 \\ \\ 斜杠 \\ &#39; ‘ 单引号 &quot; ”双引号 \\t tab 缩进 \\b 空格 ，b 是 blank 的意思 字符串长度 ​ 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 字符串拼接加强 经常会将字符串和变量来拼接，变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 Undefined 未定义型 var a; console.log(a) 默认值：undefined Null 空值 var a=null; console.log(a) 默认值：null 一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果） 一个声明变量给 null 值，里面存的值为空 获取数据类型typeof 可用来获取检测变量的数据类型 通过 console.log() 打印出来的数据颜色也可以判断数据类型 字面量 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 数据类型转换转化为字符型 方法 说明 use toString() 转成字符串 var num = 233; var str = num.toString(); String() 强制类型转换字符串 var num = 233; var str = String(num); + 字符串拼接 var num = 233; var str = num +&#39;&#39;; 使用 + 号转换为字符串是利用了 Js 的语法特性，也称为隐式转换。 转换为数字型 方法 说明 use parseInt() 转换为整数值型 parseInt(&#39;233px&#39;); parseFloat() 转化为浮点数值型 parseFloat(&#39;23.33&#39;); - * / 隐式转换 &#39;23&#39; - 0 注意 parseInt 和 parseFloat 单词的大小写，这2个是重点 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型 转换为布尔型 方法 说明 use Boolean() 转换为布尔型 Boolean(&#39;true&#39;) 代表空、否定的值会被转换为 false ，如 &#39;&#39;、0、NaN、null、undefined 其余值都会被转换为 true 解释型 和 编译型语言概述计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译，生成中间代码文件 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器) 执行过程 关键字和保留字标识符标识符：就是指开发人员为变量、属性、函数、参数取的名字。 标识符不能是关键字或保留字。 关键字关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。 保留字保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。 包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。 注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。"},{"title":"移动WEB开发之响应式布局","date":"2020-08-13T16:00:00.000Z","url":"/blog/2020/08/14/FontEnd-2020-8-MobileWeb-respon/","tags":["CSS","HTML","Bootstrap"],"categories":["FrontEnd"],"content":"所谓响应式布局就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。 Bootstrap 入门 响应式开发原理就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。 设备的划分情况： 小于768的为超小屏幕（手机） 768~992之间的为小屏设备（平板） 992~1200的中等屏幕（桌面显示器） 大于1200的宽屏设备（大桌面显示器） 响应式布局容器 响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。 原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。 父容器版心的尺寸划分 超小屏幕（手机，小于 768px）：设置宽度为 100% 小屏幕（平板，大于等于 768px）：设置宽度为 750px 中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px 大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px 但是我们也可以根据实际情况自己定义划分 快速理解 响应式 Tab 栏 ::: details ::: Bootstrap简介Bootstrap 来自 Twitter（推特），是目前最受欢迎的前端框架。Bootstrap 是基于 HTML CSS 和 javascript 的，它简洁灵活，使得 Web 开发更加快捷。 中文网 框架：顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。 框架使用请积极参考框架文档 优点 标准化的html+css编码规范 提供了一套简洁、直观、强悍的组件 有自己的生态圈，不断的更新迭代 让开发更简单，提高了开发的效率 现状2.x.x：停止维护,兼容性好,代码不够简洁，功能不够完善。 3.x.x：目前使用最多,稳定,但是放弃了IE6-IE7。对 IE8 支持但是界面效果不好,偏向用于开发响应式布局、移动设备优先的WEB 项目。 4.x.x：最新版，目前还不是很流行，文档中文残缺 2020-8-14 记录 使用现阶段我们只使用其中的样式库 前往 官网 下载用于生产环境的 Bootstrap。 创建文件夹结构 创建 html 骨架结构 ::: details ::: 引入相关样式文件 书写内容 直接拿 Bootstrap 预先定义好的样式来使用 修改 Bootstrap 原来的样式，注意权重问题。 学好 Bootstrap 的关键在于知道它定义了哪些样式，以及这些样式能实现什么样的效果。 布局容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 或者 .container-fluid 容器，它提供了两个作此用处的类。 .container 响应式布局的容器 固定宽度 大屏 ( &gt;=1200px) 宽度定为 1170px 中屏 ( &gt;=992px) 宽度定为 970px 小屏 ( &gt;=768px) 宽度定为 750px 超小屏 (100%) .container-fluid 流式布局容器 百分百宽度 占据全部视口（viewport）的容器。 栅格系统Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视 viewport 尺寸的增加，系统会自动分为最多12列。 栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 超小屏幕(手机) &lt; 768px 小屏设备(平板) &gt;=768px 中等屏幕(桌面显示器) &gt;=992px 宽屏设备(大桌面显示器) &gt;=1200px .container 最大宽度 自动 100% 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列数 12 12 12 12 按照不同屏幕划分为1~12 等份 行（row） 可以去除父容器作用15px的边距 xs-extra small：超小； sm-small：小； md-medium：中等； lg-large：大； 列（column）大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列 每一列默认有左右15像素的 padding 可以同时为一列指定多个设备的类名，以便划分不同份数 例如 class=&quot;col-md-4 col-sm-6&quot; 快速理解 栅格系统 ::: details ::: 栅格嵌套栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-* 元素内。 列偏移使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距（margin）。 列排序通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。 响应式工具为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。 class xs sm md lg .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 同样的展示类名 .visible-xx "},{"title":"Web 面试题库","date":"2020-08-11T16:00:00.000Z","url":"/blog/2020/08/12/FontEnd-2020-8-FrontEndInterview/","tags":["CSS","HTML","JavaScript","Other"],"categories":["FrontEnd"],"content":"前端1. css 加载阻塞问题问题： css 加载是否会阻塞 html 和 javascript ？ 结论： css 加载不会阻塞 DOM 树解析 css 加载会阻塞 DOM 树渲染 css 加载会阻塞 JavaScript 的运行 分析： 浏览器解析网页流程图： 根据流程图，HTML 和 CSS 同步解析，所以 css 不会阻塞 DOM 解析，但是在渲染 DOM 树时需要 css 文件进行渲染，所以 css 加载会阻塞 DOM 渲染，最后 JavaScript 想要操作 DOM 节点，修改节点样式同样需要 DOM 树渲染完成后才能执行，所以 css 加载间接阻塞了 JavaScript 的执行。 2. innerHTML 效率问题问题： 三种动态创建页面元素的方法中，哪个效率最高？ 结论： 使用数组追加方式执行的 innerHTML 效率最高。 分析： 一般情况下使用字符串拼接形式的 innerHTML 的效率是最底下的，但是改用数组方式进行字符串拼接这种方式能将 innerHTML 效率提至最高。 3. 事件委托原理问题问题： 请简述事件委托 实现方式/原理 。 结论： 不为每个子节点单独设置事件监听器，而是将事件监听器设置在其父节点上，然后利用冒泡原理捕获子节点事件，并提供事件属性判断是哪一个子节点被点击，并作出相应动作。 分析： 事件冒泡特性，指事件会从事件源元素逐级往上传递，通过设置事件监听器捕获该事件。详见 DOM 事件 &gt; 事件委托 4. 浏览器内核理解问题浏览器内核包括两部分，渲染引擎（Rendering Engine）和 js 引擎。渲染引擎负责读取网页内容，整理讯息，计算网页的显示方式并显示页面，js引擎是解析执行js获取网页的动态效果。 后来 js 引擎越来越独立，内核就倾向于只指渲染引擎。 浏览器 内核 备注 IE Trident IE、猎豹安全、360极速浏览器、百度浏览器 firefox Gecko flash 的落幕，firefox 也开始进入夕阳 Safari webkit 苹果研发的内核，在移动端被大量使用 chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 Opera blink 现在跟随chrome用blink内核。 Edge Chromium 新版Edge目前受到了大量的好评 "},{"title":"移动WEB开发之rem布局","date":"2020-08-11T16:00:00.000Z","url":"/blog/2020/08/12/FontEnd-2020-8-MobileWeb-rem/","tags":["CSS","HTML","Less","webReprint"],"categories":["FrontEnd"],"content":"rem 是相对于唯一元素 html 标签的字体大小单位。通过媒体查询动态更改 html 的字体大小，从而达到适配不同屏幕尺寸。 媒体查询 less 初识 rem 基础rem 单位 rem 是一个相对单位，类似于em 是相对于父元素字体大小。 不同的是 rem 的基准是相对于 html 元素的字体大小。 rem 的优势：父元素文字大小可能不一致， 但是整个页面只有一个 html，可以很好来控制整个页面的元素大小。 媒体查询什么是媒体查询 媒体查询 Media Query 是 CSS3 新语法。 使用 @media 查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机，Android手机，平板等设备都用得到多媒体查询 媒体查询语法规范 用 @media开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性必须有小括号包含 1. mediatype 媒体查询 ​ 将不同的终端设备划分成不同的类型，称为媒体类型 属性 说明 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等 2. 关键字 ​ 关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and ：可以将多个媒体特性连接到一起，相当于“且”的意思。 not ：排除某个媒体类型，相当于“非”的意思，可以省略。 only ：指定某个特定的媒体类型，可以省略。 3. 媒体特性 ​ 每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同 的展示风格。我们暂且了解三个。 ​ 注意他们要加小括号包含 属性 说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域的宽度 max-width 定义输出设备中页面最大可见区域的宽度 4. 媒体查询书写规则 注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁 案例：根据页面宽度改变背景颜色 实现思路： 按照从大到小或者从小到大的思路 注意 max-width 和 min-width 都是包含等于的 当屏幕小于540像素，背景颜色为蓝色 x &lt;= 539 当屏幕大于等于540像素，且小于等于 969像素背景色为绿色 540 &lt;= x &lt;= 969 当屏幕大于970像素，背景为红色 x &gt;= 970 源码： ::: details ::: 媒体查询 + rem 实现元素动态大小变化 rem 是相对于 html 的 font-size 变化的，现在通过媒体查询我们可以动态的设置不同设备的 html 的 font-size 属性，进而使 rem 在不同设备是展示不同形态。 案例：媒体查询+rem实现Header元素变化 ::: details ::: 引入资源 当当前页面的样式比较多时，我们可以针对不同的媒体宽度引入不同的 css 样式表。 直接在 link 中判断设备尺寸，然后应用不同的 css 文件。 1. 语法规范 案例：不同屏幕宽度引入不同样式 ::: details ::: Less 基础维护css弊端 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 Less 介绍 Less（ LeanerStyle Sheets 的缩写）是一门 CSS 扩展语言，也成为 CSS 预处理器。 做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入程序式语言的特性。 它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，Less 可以让我们用更少的代码做更多的事情。 Less中文网 常见的 CSS 预处理器：Sass 、Less 、Stylus … Less 是一门 CSS 预处理语言，它扩展了CSS 的动态特性。 Less 安装 安装 nodejs ，可选择版本(8.0)，网址： 检查是否安装成功，使用 cmd 命令（ win10 是 window+r 打开运行输入cmd ） 输入node –v 查看版本即可 基于 nodejs 在线安装 Less ，使用 cmd 命令 npm install -g less 即可 检查是否安装成功，使用 cmd 命令 lessc -v 查看版本即可 快速开始 npm Less 使用 1. 变量 变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 更多 Less 使用请参考 Less中文网 Less 编译 在 Vscode 扩展商店查找并安装 Easy LESS （作者：mrcrowl ） 该插件在你每次保存 .less 文件时，都会自动编译出 .css 文件。 Less 嵌套 和 css 一样， less 也支持选择嵌套。 注意，不要理解为继承！！ 如果遇见 （交集|伪类|伪元素选择器） ，利用&amp;进行连接 Less 运算 任何数字、颜色或者变量都可以参与运算。就是 Less 提供了加，减，乘，除算术运算。 乘号 * 和除号 / 的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 rem 适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。 ::: tip 技术方案： less + rem + 媒体查询 lflexible.js + rem ::: 总结： 两种方案现在都存在。 方案2 更简单，现阶段大家无需了解里面的 js 代码。 rem 实际开发适配方案1 假设设计稿是 750px 假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份） 每一份作为 html 字体大小，这里就是 50px 那么在 320px 设备的时候，字体大小为 320/15 就是 21.33px 用我们页面元素的大小除以不同的 html字体大小会发现他们比例还是相同的 比如我们以 750 为标准设计稿 一个 100*100 像素的页面元素在 750 屏幕下， 就是 100/ 50 转换为 rem 是 2rem*2rem 比例是1比1 320屏幕下， html 字体大小为21.33 则 2rem = 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1比1 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果 总结： 最后的公式：页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分的份数） 屏幕宽度/划分 的份数就是 html font-size 的大小 或者：页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小 rem 实际开发适配方案2 手机淘宝团队推出的简洁高效移动端适配库 我们再也不需要在写不同屏幕的媒体查询，因为里面 js 做了处理 它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。 我们要做的，就是确定好我们当前设备的 html 文字大小就可以了 比如当前设计稿是 750px ， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以 里面页面元素rem值： 页面元素的 px 值 / 75 剩余的，让 flexible.js 来去算 github地址： 总结： 因为 flexible 是默认将屏幕分为10等分 但是当屏幕大于750的时候希望不要再去重置 html 字体了 所以要自己通过媒体查询设置一下 并且要把权重提到最高 苏宁首页案例制作苏宁首页地址 ：苏宁首页 方案1 技术选型 方案：我们采取单独制作移动页面方案 技术：布局采取rem适配布局（less + rem + 媒体查询） 设计图： 本设计图采用 750px 设计尺寸 搭建文件结构 设置视口标签以及引入初始化样式 设置公共 common.less 文件 新建 common.less 设置好最常见的屏幕尺寸，利用媒体查询设置不同的html 字体大小，因为除了首页其他页面也需要 我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px 划分的份数我们定为 15 等份 因为我们 pc 端也可以打开我们苏宁移动端首页，我们默认 html 字体大小为 50px ，注意这句话写到最上面 新建 index.less 文件 新建 index.less ，在这里书写首页样式 将刚才设置好的 common.less 引入到 index.less 里面，语法如下 生成 index.css 引入到 index.html 中。 **源码：suning-firstPlan ** 有感：尽管在这种方案中 less 帮我们完成了 rem 的计算，但是大量的的算术表达式导致语法键入极其困难。可是，这种方案布局出来的网页适配屏幕是相当优秀的，可以轻易适配出各种屏幕尺寸的最佳效果。 方案2简洁高效的 rem 适配方案 flexible.js Vscode px 转 rem 插件 ：**cssrem** 注意修改插件配置的 Cssrem:Root Font Size 源码：suning-secondPlan "},{"title":"移动WEB开发之流式布局","date":"2020-08-10T16:00:00.000Z","url":"/blog/2020/08/11/FontEnd-2020-8-MobileWeb-fluid/","tags":["CSS","HTML","WebReprint"],"categories":["FrontEnd"],"content":"所谓流式布局，即指使用 百分比% 作为元素单位，从而实现适配不同屏幕尺寸 移动端网页开发现状 视口 1.0 移动端基础1.1浏览器现状 PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。 移动端常见浏览器：UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，以及其他杂牌浏览器。 国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。 总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。 1.2 手机屏幕的现状 移动端设备屏幕尺寸非常多，碎片化严重。 Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，近年来也出现了2K，4k屏。 近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。 1.3常见移动端屏幕尺寸1.4移动端调试方法 Chrome DevTools（谷歌浏览器）的模拟手机调试 搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器 使用外网服务器，直接IP或域名访问 2.0 视口视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口 2.1 布局视口 layout viewport一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。 iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 2.2 视觉视口 visual viewport字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。 2.3 理想视口 ideal viewport为了使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口，对设备来讲，是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽 总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口 2.4 meta标签最标准的viewport设置 视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 3.0 二倍图3.1 物理像素&amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是 750* 1334 我们开发时候的1px 不是一定等于1个物理像素的 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比 如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放 lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。 对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊 在标准的 viewport 设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题 通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题 3.2 背景缩放background-size background-size 属性规定背景图像的尺寸 单位： 长度|百分比|cover|contain; cover：把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain ：把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 4.0 移动开发选择和技术解决方案4.1 移动端主流方案 1. 单独制作移动端页面（主流） 通常情况下，网址域名前面加 m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。 也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站 京东PC端： 京东移动端： 2.响应式页面兼容移动端（其次） 三星中国官网： 响应式网站：即PC和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配 4.2 移动端技术解决方案1.移动端浏览器兼容问题 移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。 我们可以放心使用 H5 标签和 CSS3 样式。 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 2.移动端公共样式 移动端 CSS 初始化推荐使用 normalize.css Normalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址：  4.3 移动端大量使用 CSS3盒子模型box-sizin传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型： 盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding 也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了 移动端可以全部CSS3 盒子模型 PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型 4.4移动端特殊样式 5.0移动端常见布局移动端单独制作 流式布局（百分比布局） flex 弹性布局（强烈推荐） less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp 3.0 流式布局流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式。 4.0 京东移动端首页案例制作京东为移动端采用单独的页面样式，并使用了典型的流式布局方案。 source：京东移动端静态页面复刻 "},{"title":"CSS3 渐变色字体","date":"2020-08-08T16:00:00.000Z","url":"/blog/2020/08/09/FontEnd-2020-8-GradientFront/","tags":["CSS"],"categories":["FrontEnd"],"content":" CSS3 渐变色字体实现步骤首先肯定需要使用到渐变色彩语法 关键属性是设置背景渲染区域为文本 再设置文本颜色为透明即可。 完整代码： 效果展示效果： 渐变色字体 .color-liner { background: linear-gradient(190deg, #45CAFF,#1471FB); -webkit-background-clip: text; -moz-background-clip: text; background-clip: text; color: transparent; font-size:23px !important; font-weight: bold !important; } "},{"title":"京东移动端Banner背景圆弧实现","date":"2020-08-08T16:00:00.000Z","url":"/blog/2020/08/09/FontEnd-2020-8-JDM-Banner-background-radio/","tags":["CSS"],"categories":["FrontEnd"],"content":"在京东移动端复刻时，发现了一个比较有意思的实现。基于 2020-8-9 的京东移动端。 刚开始以为是图片背景，查看源码后发现不是这么简单，应该是使用 css 实现的样式。经过一番查阅和推敲实现了目标样式。 基本实现思路： 使用父子两个 div 进行嵌套。 设置子 div 的 border-radius: 0 0 50% 50%; 此时的圆弧并不符合要求，将其 width 放大到 140% 得到更加圆润的弧部 再将其移至中心 left: -20%; 移动多放大的 40% 的一半 20% 即可。 通过父 div overflow: hidden; 裁去多余部分即可。 理解图示： 由于在手机检查下无法看见溢出，使用了PC预览宽度被拉伸了一些，重在理解。 最终实现： "},{"title":"初识 Git","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/Other-Git-Github-start/","tags":["Git","Github"],"categories":["Others"],"content":" Git 是一个版本管理控制系统 VCS ，它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。 官方文档 Gitee Git DocGithub Git suebootcss Git 简易指南ProGit 进阶 版本管理版本管理是一种记录文件变化的方式，以便将来查阅特定版本的内容 部署下载Git官网 工作流程工作区：项目在开发者设备上的目录 暂存区：用于暂时存储需要提交的仓库的文件，使用 git add 命令将文件提交到暂存区 本地仓库 ：正式存储代码的位置，接收来自暂存区的文件，使用git commit 命令正式提交到仓库，注意在正式提交前务必对暂存区代码进行完整测试。 远程仓库：存储在公共网络上的代码托管网站。 命令语法 命令 操作 git --version 查看 Git 版本 Git使用配置Git在使用 git 前，需要告诉 git 你是谁，在向 git 仓库提交时需要辨识当前修改的提交者，这是利于多人协作的。 配置提交人姓名：git config --global user.name 提交人姓名 配置提交人邮箱：git config --global user.email 提交人邮箱 查看 git 配置信息：git config --list 多次输入配置信息会覆盖之前的配置信息 除了通过使用命令行进行配置外，也可以找到 C:/user 下的 .gitconfig 提交步骤 git init 初始化 git 仓库 git status 查看文件状态 git add 文件列表 添加/更新 文件到暂存区 git commit -m 提交信息 向仓库提交暂存区 git log 查看提交记录 每次 修改/增加 工作目录都需要执行 git add 密码来加入暂存区 git 提交规范： 一次提交只包含一个改动 在提交到仓库之前，一定要经过完整测试 commit message 不能忽略，书写提交信息一定要简洁明了，一句点明当前提交改动 恢复记录用暂存区中的文件覆盖工作目录中的文件：git checkout 文件 将文件从暂存区中删除：git rm --cached 文件 将 git 仓库中指定的更新记录恢复，并且覆盖暂存区和工作目录：git reset --hard commitID 通过 git log 来查看commit ID 分支分支相当于工作目录的副本，多人协作时，其他人可以通过分支将其从开发主线上分离出来，以免影响开发主线。 分支的意义：如果没有分支我们可以想象在一个开发流程下我们同时对代码进行新功能添加，bug修复，代码重构，UI更替等等操作，可想而知是十分繁杂凌乱的，通过分支我们可以将不同的模块细分出去，更好的管理开发流程 分支细分 主分支（master）：第一次向 git 仓库提交更新时会自动产生该分支。 开发分支（develop）：作为开发的分支，基于 master 分支创建。 功能分支（feature）：作为开发具体功能的分支，基于开发分支创建。 分支命令 git brach 查看分支列表 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git merge 来源分支 合并分支 git branch -d 分支名称 删除分支（分支被合并后才能删除）-D 强制删除 在切换分支时务必保证暂存区的文件已经commit到仓库，否则暂存区文件会影响到切换分支的工作区。 在当前分支下时，是无法删除本分支的，只有切换到其他分支才能对分支进行删除操作。 Git进阶暂时保存更改在 git 中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。 使用场景：分支临时切换 git stash 存储临时改动 git stash pop 恢复改动 Github在 Git 中有90%的操作都是在本地仓库中进行的，这样已经足以满足个人项目开发的所有需求了。但是往往一个项目是需要多人协作开发的，这时我们就需要一个别人也可以进行访问的远程仓库。 Github 团队协作开发流程 A 在自己的计算机中创建本地仓库 A 在 github 中创建远程仓库 A 将本地仓库推送到远程仓库 B 克隆远程仓库到本地进行开发 B 将本地仓库开发内容推送到远程仓库 A 将远程仓库中的最新内容拉取到本地 推送创建新仓库并推送到远程仓库 推送已有仓库至远程仓库 第一行代码是为远程仓库设置别名 origin ，这个名字是可更改的 第二行参数是以 master 分支推送至远程仓库 ，-u 参数是记忆当前操作，在下次推送时只需要使用 git push 即可。 克隆克隆远程仓库到本地 如果需要推送给A需要在远程仓库的Settings -&gt; Manage access -&gt; Invate a collaborator来添加协作者 并复制邀请链接给程序员B 程序员B 访问邀请链接，并接受邀请 github 的远程仓库账号存储在了 Windows凭据 下，如果需要切换登录需要手动删除凭据 拉取拉取远程仓库到本地 git pull 是在已经有本地仓库的基础上进行的，他会将本地仓库的版本与远程仓库版本进行比对，更新最新版本的代码。 git clone 是完全复制下远程仓库，是本地不存在仓库时进行。 如果远程仓库中的版本高于本地仓库的版本，本地仓库不能向远程仓库提交，只有先拉取远程仓库之后才能提交。 解决冲突在多人协作时，可能会出现两个人对同一个文件的同一个地方进行了修改，就会发生冲突，冲突需要人为解决。 即只有第一个向远程仓库提交的人才能推送，第二个推送的人因为本地仓库版本低于远程仓库无法提交，只有拉取远程仓库进行提交，但是由于两个人修改了同一个文件的同一个地方，导致了冲突发生 报错提示 选择处理，删除多余字符，解决冲突 跨团队协作作为非团队成员进行协作时，提交的代码需要审核才能生效 Fork 需要协作的仓库，会将目标仓库复制到自己的 github 账号下，之后可以进行远程仓库的克隆，然后开始修改，推送。 完成推送后在远程仓库点击 Pull requests -&gt; New pull request -&gt; Create pull request -&gt; 与原仓库作者送信 -&gt; Create pull request 这时在原仓库的作者的项目仓库下会有新的 Pull requests 拉取请求，点击之后就可以看见 fork者的合并请求，也可与 fork者进行回复，点击 Files changed 查看修改代码。 在对话页面点击 Marge pull request 即可应用合并。 ssh免登陆https协议进行远程仓库链接，每次推送操作都要输入账号密码进行验证，但是 Windows 系统为我们提供了凭证，可以让我们不用每次都进行输入验证，但是当在其他操作系统上时就无法这样了。 所以 Github 提供了另一种链接协议 ssh ，在 ssh 中身份验证通过密钥实现，分为公钥与私钥，只有当公私钥匹配成功才能通过验证。 生成密钥 存储在 C:/user/.ssh/ id_rsa 为私钥，必须存储在开发者系统下 id_rsa.pub 为公钥，这个公钥则需要存储在 Github 下 user -&gt; Settings -&gt; SSH and GPG keys -&gt; new ssh key 填写key 之后再 仓库页面就可以通过 Clone or download 来切换获取 ssh 链接。 Gitignore在工作区添加 .gitignore 文件，在 push 时 GitHub 会忽略 .gitignore 文件中的文件"},{"title":"Markdown 语法入门","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/Other-MarkdownCheck/","tags":["Markdown"],"categories":["Others"],"content":" 书写文档从未如此优雅 1. 初识Markdown 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素。Markdown 由 John Gruber 于 2004 年创建，如今已成为世界上最受欢迎的标记语言之一。 Markdown中文指南 简书语法速查 菜鸟入门教程 你可能想知道为什么人们使用 Markdown 而不是所用即所得（WYSIWYG）编辑器。当你可以通过按下界面中的按钮来设置文本格式时，为什么还要使用 Markdown 来书写呢？事实证明，人们使用 Markdown 而不是 WYSIWYG 编辑器的原因有两个： Markdown 处处可用。人们使用它来创建 网站、文档、便签、书籍、演示文稿、邮件 和 技术文档。 Markdown 是可移植的。几乎可以使用任何应用程序打开包含 Markdown 格式的文本文件。如果你不喜欢当前使用的 Markdown 应用程序了，则可以将 Markdown 文件导入另一个 Markdown 应用程序中。这与 Microsoft Word 等文字处理应用程序形成了鲜明的对比，Microsoft Word 将你的内容锁定在专有文件格式中。 Markdown 是独立于平台的。你可以在运行任何操作系统的任何设备上创建 Markdown 格式的文本。 Markdown 能适应未来的变化。即使你正在使用的应用程序将来会在某个时候不能使用了，你仍然可以使用文本编辑器读取 Markdown 格式的文本。当涉及需要无限期保存的书籍、大学论文和其他里程碑式的文件时，这是一个重要的考虑因素。 Markdown 无处不在。例如 Reddit 和 GitHub 等网站都支持 Markdown，许多桌面和基于 Web 的应用程序也都支持 Markdown。 2. 编辑器1.1 在线 Dillinger 1.2 应用 Mou MarkdownPad Typora Atom Haroopad SublimeText Cmd Markdown Byword CuteMarkEd 1.3 插件 Atom SublimeText Dillinger 3. 基础语法3.1 标题 3.2 转行 3.3 分割线 3.4 字体样式 下划线目前 markdown 暂时没有支持语法，可以依靠 html 语法实现 3.5 列表 列表之间允许嵌套列表和其他语法格式 3.6 引用 引用允许嵌套引用和其他语法格式 3.7 图片 3.8 超链接 3.9 表格 3.10 代码 4. 扩展语法4.1 HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 4.2 转义字符Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 4.3 数学公式当你需要输入数学公式时，即可使用公式块： 4.4 流程图由于流程图语法较为复杂，这里仅显示简单的流程图代码，如需深入了解，参考 4.5 目录目录会在指定位置自动生成当前文档的标题结构 4.6 脚注 4.7 完成清单 4.8 Emoji表情完整 emoji 表情请参考 list of emoji shortcodes 4.9 锚点定位 5. 流程图示例Markdown 支持在文档中使相关语法创建流程图。这些流程图都是通过渲染代码生成的。 5.1 初识 5.2 横向流程图 5.3 标准流程图 @flowstartst=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框 st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op@flowend 5.4 UML时序图 5.5 UML时序图复杂 5.6 UML标准时序图 5.7 甘特图 "},{"title":"BOM 浏览器对象模型","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-BOM/","tags":["BOM"],"categories":["FrontEnd"],"content":"BOM 封装了浏览器的各项操作，并允许程序员通过 js 语法调用这些操作，如：返回上一页，读取 cookie，调整浏览器窗口等等 BOM 概述BOM （Browser Object Model） 即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。 BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 BOM 缺乏标准，JavaScript 语法标准的组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是 Netscape 浏览器标准的一部分。 DOM 文档对象模型 DOM 就是将文档当成一个对象来看 DOM 的顶级对象是 document DOM 主要是学习操作页面元素 DOM 是 W3C 标准 BOM 浏览器对象模型 把浏览器当成一个对象 BOM 的顶级对象是 window BOM 学习的是浏览器窗口交互。 BOM 是浏览器厂商在各自浏览器上定义的，混乱，难以兼容 BOM 构成 window 对象是浏览器的顶级对象，它具有双重角色 它是 JS 访问浏览器窗口的一个接口 它是一个全局对象，定义在全局作用域中的变量，函数都会变成 window 对象的属性和方法 在调用方法属性时我们一般忽略 window. window.name 是一个存在的属性，在声明变量时注意避免 window 事件窗口加载事件 当页面所有元素加载完成后触发该事件。 传统事件注册方式的特性依旧存在，只会执行代码顺序的最后一个 onload 事件函数 注册监听事件方式特性也存在，没有限制 DOM 加载事件 当 DOM 加载完成触发，不包括 css image flash 等等 应用场景： 当页面存在大量图片时，用户触发 onload 可能会需要很长时间，这期间无法实现交互效果，必然影响用户体验，这时使用 DOMContentLoaded 事件比较合适。 调整窗口大小事件 当浏览器窗口发生改变时，触发该事件。 应用场景： 响应式布局， winow.innerWidth 当前屏幕宽度， winow.innerHeight 当前屏幕高度。 定时器window 对象为我们提供了2个定时器语法。 setTimeout() 方法 参数： function ：调用函数 time : 延迟时间，单位 ms setTimeout() 方法可以在指定时间后执行一次调用函数。这个函数方法也称为回调函数 callback 普通函数是按照代码顺序执行的，而回调函数是在先完成一个函数方法后去调用另一个方法。 element.onclick = function() 和 element.addEventListener(&#39;click&#39;,fn) 都是回调函数。 window 可以省略 调用函数可以直接写匿名函数，或声明函数，也可以使用 &#39;fun()&#39; 这种写法，但是并不推荐 延迟的时间可以忽略，即为 0 ，立即执行 setInterval() 方法 参数： function ：回调函数 time : 间隔时间，单位 ms setInterval() 方法可以每间隔 time 执行一次回调函数，只有通过 clearInterval() 方法才能清除终止该定时器。 停止定时器 清除 setTimeout 清除 setInterval JS 执行队列JavaScript 语言的一大特定就是单线程，同一时间只能做一件事。这是因为 JavaScript 这门脚本语言诞生的使命所致的—— JavaScript 是为处理页面中的用户交互，以及操作 DOM 而诞生的。当我们对某个 DOM 元素进行操作时，是不能同时创建和删除的。 单线程就意味着任务队列的存在，前一个任务结束完之后，才会执行后一个任务。这样就会导致如果 JS 执行时间过长，就会造成页面渲染不连贯，加载阻塞。 同步和异步 为了解决阻塞问题，利用多核 CPU 的计算能力， HTML5 提出 Web Worker 标准，运行 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。 同步 前一个任务执行完成后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致，同步的。即允许阻塞。 异步 前一个任务执行时，不等待其执行完毕，将其独立运行，接着其他任务。 同步任务 同步任务都在主线程上执行，形成一个 执行栈 异步任务 JS 的异步任务都是通过回调函数实现的 普通事件：click, resize 资源加载：load, error 定时器：setInterval , serTimerout 异步任务相关回调函数添加到 任务队列 中（消息队列） 执行机制 先执行执行栈中的同步任务。 如果遇见执行栈中的异步任务（回调函数）会被放到任务队列之中（消息队列），并不执行。 当执行栈中的所有同步任务执行完毕后，系统会依次读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 异步进程处理会保管回调函数，当事件触发时再将回调函数加入消息队列 执行栈会不停检查任务队列中的任务，如果有就取出执行，这个闭环被称为事件循环 location 对象window 对象为我们提供了一个 location 属性用于获取或设置窗体的URL，并且可以用于解析 URL。因为属性返回的是一个对象，所以我们将这个属性也称为 location 对象。 URL 统一资源定位器 (Uniform Resource Locator) 是互联网上标准资源地址。互联网上的每个文件都有一个唯一的 URL ，它包含信息指出文件位置并告诉浏览器应该怎么处理它。 URL 一般语法： protocol://host[:port]/path/[?query]#fragment location 对象属性与方法 属性/方法 返回 location.href 获取或设置整个 URL location.host 返回主机（域名） location.port 返回端口号 如果未写返回空字符串 location.pathname 返回路径 location.search 返回 query 参数 location.hash 返回片段 # 后的内容 localtion.assign() 页面重定向 记录浏览历史 localtion.replace() 替换当前页面 不记录浏览历史 localtion.reload() 重新加载页面 刷新 参数为 true 强制刷新 navigator 对象navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 navigator.userAgent ，该属性可以返回由客户端发送服务器的 user-agent 头部的值。 在浏览器打开任意网页开启控制的通过输入 navigator 查看其相关属性 history 对象history对象用于与浏览器历史记录的交互。其包含了用户的浏览记录即访问过的 URL。 history对象方法 方法 说明 back() 返回历史上一个页面 forward() 前进 go() 前进后退功能 里面填写整数确定需要前进后台的历史条目 本章案例5秒后自动关闭广告实现思路： 当页面加载完成 onload ，添加定时器 setTimeout ，到时display隐藏广告 倒计时实现思路： 倒计时不断变化，因此需要定时器 setInterval 自动变化 三个黑子分别存放时分秒 使用 innerHTML 放入计算的时分秒 在执行 setInteval 时存在空白期，通过先调用一次封装函数的方法解决这个问题 发送冷却需求：当用户点击发送按钮后，按钮不可点击，并显示 xx 秒后才可再次点击 实现思路： 按钮点击之后，会禁用按钮 disabled 同时按钮内容变化，通过 innerHTML 修改 内容动态变化，需要定时器 setInterval 定义变量，在定时器中自减 如果变量自减为 0 ，复原按钮，并重置倒计时 应用场景： 高强度文本聊天 短信验证冷却 5秒后跳转页面实现思路： 设置 setInterval 定时器，每秒倒计时改变页面内容 到 0 时，使用 location.href 跳转页面 获取 URL 参数要求：用户再登录页面输入数据，点击登录之后页面跳转并展示登录页面用户输入的内容 实现思路： 为登录页面的表单添加 action 到展示页面。 action get 会将表单数据拼接到 URL 中。 在展示页面从 location.search 获取之前的用户输入 "},{"title":"DOM 事件进阶","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-DOM-event-high/","tags":["DOM"],"categories":["FrontEnd"],"content":"DOM 事件[[toc]] 注册事件给元素添加事件，称为注册事件或者绑定事件 注册事件有两种方式： 传统注册方式 利用 on 开头的事件 比如 ：onclick onfocus onmouseover 特点：注册事件的唯一性，即一个事件源只能有一个 on 事件，相同的 on 事件只会执行文档流最后的事件。 方法监听注册方式 w3c 标准，推荐方式 addEventListen() 方法 ie9 之前不支持此方法，解决方案使用 attachEvent() 替换 特点：一个事件源可以注册多个监听器，按注册顺序依次执行 传统注册方式 在 DOM 事件基础中已经详细介绍传统注册方式，这里不再赘述。 方法监听注册方式 关键语法： eventTarget.addEventListener() 方法将指定的监听器注册到 eventTarget (目标对象) 上，当该对象触发指定事件时，就会执行事件处理函数。 该方法接收三个参数： type ：事件类型字符串， 比如：click , mouseover … ，注意这里不需要 on listener ：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false 。为 true 时，表示在事件捕获阶段调用事件处理程序，否则在事件冒泡阶段调用。 实例： ie9兼容解决方案 （非提倡） 关键语法： eventTarget.attachEvent() 方法将指定的监听器注册到 eventTarget （目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。 该方法接收两个参数： eventNameWithOn ：事件类型字符串，比如 onclick , onmouseover … ，这里需要带上 on callback ：事件处理函数，当目标触发事件时回调函数会被调用 全版本兼容可以自行判断浏览器内核，对不同版本返回不同函数方式，封装为一个函数，在项目中使用即可 或者使用传统事件注册方式 删除事件1. 传统删除方式，即注册空事件 onEvent ：事件类型字符串，比如：onclick,onmouseover,`onfocus… 2. 方法监听删除 参数说明： type ：事件类型字符串， 比如：click , mouseover … ，注意这里不需要 on function ：移除事件函数名 使用该方法移除事件时，注册事件函数必须暴露事件名，即注册事件不能为匿名函数 DOM 事件流事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。 DOM 事件流分为3个阶段 捕获阶段 当前目标阶段 冒泡阶段 事件捕获：网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到具体元素接收的过程 事件冒泡：IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到 DOM 最顶层节点的过程 捕获阶段示意图： 冒泡阶段示意图： 个人理解总结 事件流即事件穿透/传递过程 由于 DOM 树是层层嵌套的，以点击事件为例，其传递流程应该是 Document -&gt; html -&gt; body -&gt; fatherdiv -&gt; sondiv 点击事件会从顶层逐级传递，直到被事件监听函数捕获。这个流程被称为 捕获阶段，通过 eventTarget.addEventListener(type, function, true) 设置第三个参数为 true 使事件以顶层穿透这种方式传递。 通过设置其参数为 false 即为冒泡阶段，这种方式是最常用的，该传递方式会忽略顶层穿透，逆向传递点击事件。 sondiv -&gt; fatherdiv -&gt; body -&gt; html -&gt;document 我更喜欢称之为底层穿透方式。 在实际开发中很少使用到事件捕获，我们更关注事件冒泡 某些事件是没有冒泡行为的：onblur,onfocus,onmouseenter,onmouseleave 事件冒泡机制实现一些很巧妙的功能，但有时也会带来麻烦 事件对象在监听事件函数中我们可以声明一个事件对象 event，evt，e 只有事件存在，事件对象才会存在，它里面包含了一系列事件相关数据的集合。 实例： ie678 中可以使用 window.event 获取事件对象 事件对象常见属性和方法 方法 说明 e.target 返回触发事件的对象 标准 e.srcElement 返回触发事件的对象 非标准 ie678 e.type 返回事件类型 如：click,mousemover… e.stopPropagation() 阻止事件冒泡 标准 e.cancelBubble 阻止事件冒泡 非标准 ie678 e.preventDefault() 阻止事件触发 标准 e.returnValue 阻止事件触发 非标准 ie678 我们也可以在事件中使用 return方法阻止事件运行，但是这种方法会中断 return 之后的代码运行 阻止事件冒泡事件冒泡特性有好有坏，需要灵活运用。 阻止冒泡会终止事件向上级传递。 标准语法： event ：事件对象 非标准写法： event ：事件对象 事件委托事件委托也称为事件代理，事件委派，是事件冒泡特性的运用 现有以下场景： 要求为点击每个 li 时弹出提示框，如果不使用事件冒泡特性，循环为 li 注册事件是不优雅的，而且访问的 DOM 越多，页面加载速度和交互速度也会变慢。 实现思路： 为 ul 注册点击事件，利用事件对象的 target 来找到当前点击的 li ，因为点击 li 会冒泡到 ul 上， ul 有事件注册，就会触发事件监听器。 这样我们只操作了一次 DOM 即只为 ul 添加了事件监听，提高了程序性能。 实现代码： 常用的鼠标事件 事件 触发事件 onlick 鼠标点击 onmouseover 鼠标经过 onmouseout 鼠标离开 onfocus 获得焦点 onblur 失去焦点 onmousemove 鼠标移动 onmouseup 鼠标弹起 onmousedown 鼠标按下 contextmenu 鼠标右键菜单 selectstart 鼠标选中 禁止鼠标右键菜单 禁止鼠标选中 鼠标事件对象 对象 说明 e.clientX 返回鼠标相对于浏览器可视区窗口的 x 坐标 e.clientY 返回鼠标相对于浏览器可视区窗口的 Y 坐标 e.pageX 返回鼠标相对于文档页面的 x 坐标 ie9+ e.pageY 返回鼠标相对于文档页面的 Y 坐标 ie9+ e.screenX 返回鼠标相对于电脑屏幕的 x 坐标 e.screenY 返回鼠标相对于电脑屏幕的 Y 坐标 常用的键盘事件 事件 触发条件 onkeyup 某个键弹起 onkeydown 某个键按下 onkeypress 某个键按下 不能识别功能键 如 ctrl shift 方向键… 执行顺序： keydown -&gt; keypress -&gt; keyup keyup 和 keydown 不区分按下的大小写，在事件对象中无法辨识大小写，key press 支持区分大小写 键盘事件对象 对象 说明 e.keyCode 返回按下键盘的 ASCII 值 本章案例图片跟随鼠标移动需求：需要一张图片在页面中跟随用户鼠标移动 实现思路： 鼠标不断移动，鼠标移动事件 mousemove 在整个页面移动，给 document 注册事件 图片要移动位置，但是不占据页面空间，使用 absolute 定位 每次移动鼠标，都会获取新的鼠标坐标，将这个坐标设置为图片的 top left 值即可。 点击按键聚集焦点需求：当用户在页面按下 s 键时，搜索框获得焦点，开始输入。 实现思路： 为 document 添加按键监听事件 使用键盘事件对象中的 keyCode 判断用户按下的键 使用 focus() 方法使文本框获取焦点 输入内容显示放大需求：当用户在表单输入时，浮现用户输入内容到上方并放大输入内容。 实现思路： 用户输入，div 盒子显示 检测用户输入，为表单添加键盘事件 将表单 value 获取并通过 innerHTML 赋值给div 如果输入为空则隐藏 div 注意 keydown，keypress的触发时机，当按键按下时立即触发，但是此时表单并没有进行输入 这是keydown，keypress在表单输入的特性 "},{"title":"移动WEB开发之flex布局","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-MobileWeb-flex/","tags":["CSS","HTML","WebReprint"],"categories":["FrontEnd"],"content":"flex 布局又称弹性布局，个人最喜欢的布局方式，通过设置元素的 display:flex 属性，可以快速完成页面布局，体验良好，多多益善。 1. flex布局体验1.1 传统布局与flex布局 传统布局 flex 弹性布局 兼容性好 IE 11 或更低版本，不支持或仅部分支持 布局繁琐 操作方便，布局极为简单，移动端应用广泛 局限性，不能再移动端很好的布局 PC 端浏览器支持情况较差 1.2 初体验 2. flex布局原理2.1 布局原理flex 是 flexible Box 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flexitem），简称”项目”。 总结：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式 3. 父项常见属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap 3.1 flex-direction设置主轴的方向 在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴方向就是 y 轴方向，水平向下 注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 属性 描述 row 默认从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 3.2 justify-content 设置主轴上的子元素排列方式注意：在使用该属性之前，请确定当前主轴。 属性 描述 flex-start 默认值 从头部开始 如果主轴是x轴，则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐（如果主轴是x轴则水平居中） space0around 平分剩余空间 space-between 先两边贴边 再平分剩余空间（重要） 3.3 flex-wrap设置是否换行 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex 布局中默认是不换行的。 nowrap 不换行 wrap 换行 3.4 align-items 设置侧轴上的子元素排列方式（单行 ） 该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用 flex-start 从头部开始 flex-end 从尾部开始 center 居中显示 stretch 拉伸 3.5 align-content 设置侧轴上的子元素的排列方式（多行）设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。 属性 描述 flex-start 默认值 在侧轴的头部开始排列 flex-end 在侧轴尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先两头分布，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 3.6 align-content 和align-items区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找align-items 多行找 align-content 3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性 4. flex布局子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） 4.1 flex 属性flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 4.2 align-self控制子项自己在侧轴上的排列方式align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 4.3 order 属性定义项目的排列顺序数值越小，排列越靠前，默认为0。 注意：和 z-index 不一样。 5. 携程网首页案例制作携程网链接： 1. 技术选型 方案：我们采取单独制作移动页面方案 技术：布局采取flex布局 2. 搭建相关文件夹 3. 设置视口标签以及引入初始化样式 4. 常用初始化样式 5. 模块名字划分 source：携程网移动端静态页面复刻 "},{"title":"[项目实战] 多人博客管理系统","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-Project-BlogManageSystem/","tags":["ProjectPractice","Node.js","MongoDB","Express","Art-template"],"categories":["FrontEnd","BackEnd"],"content":"![]( =700x) 技术栈：node.js + express + mongodb + bootstrap 实现功能： 登录注册 文章管理 用户管理 文章评论 项目仓库地址 ：QiJieH/BlogMS 项目实战 多人博客管理系统 快速预览: ![]( =700x) ![]( =700x) ![]( =700x) ![]( =700x) 运行说明请使用 nodemon 开启网站监听。注意初次部署你可能需要自行添加数据库中的用户信息。 1. 项目环境搭建nodejs + mongodb + express 1.1 项目介绍 博客内容展示 博客管理功能 1.2 案例初始化 建立项目文件结构 public 静态资源 model 数据库操作 route 路由 views 模板 初始化项目描述文件 npm init -y 下载项目依赖的第三方模块 npm install express mongoose art-template express-art-template 创建网站服务器 构建模块化路由 构建博客管理页面模板 2. 登录 包含一般正常的登录逻辑，即账号密码验证 2.1 登录功能实现步骤 创建用户集合，初始化用户 连接数据库 创建用户集合 初始化用户 为登录表单设置请求地址，请求方式以及表单项name属性 当用户点击登录按钮时，客户端验证用户是否填写了登录表单 如果其中一项没有输入，阻止表单提交 服务器端接收请求参数，验证用户是否填写了表单 如果其中一项没有输入，为客户端做出响应，阻止程序向下执行 根据邮箱地址查询用户信息 如果用户不存在，为客户端做出响应，阻止程序向下运行 如果用户存在，将用户名和密码进行对比 对比成功，用户登录成功 对比失败，用户登录失败 3. 密码加密在数据库中直接明文存储用户密码是不安全的，一但数据库信息泄露，可能导致恶意登录操作用户账户，所以需要对数据库的用户密码进行加密。 3.1 密码加密 bcrypt哈希加密是单程加密方式：123 =&gt; abcd 但是这种方式仍有方法破解，攻击者可以通过创建账号密码拿到加密字符，通过字符对比获取到的其他用户数据库存储加密明文密码进行破解。 在加密的密码中加入随机字符串可以增加解密难度。 3.2 bcrypt 环境部署python 2.7  注意添加环境变量 node-gyp npm install node-gyp -g windows-build-tool npm install --global --production windows-build-tools 3.3 bcrypt 测试 3.4 密码比对 4. cookie与sessioncookie: 浏览器在电脑硬盘中开辟的一块空间，主要提供服务器存储数据 cookie中的数据是以域名的形式进行区分 cookie具有过期时间 cookie中的数据会随请求被自动发送到服务器端 session: 实际上是一个对象，存储在服务器端的内存中，在session对象中也可以存储多条数据，每一条数据都有一个sesssionid作为唯一标识 4.1 c&amp;s环境部署在node.js中需要借助express-session实现session功能 npm install express-session 4.2 登录拦截 4.3 登录注销 5. 新增用户 为用户列表新增添加按钮链接 添加一个链接对应的路由，在路由处理函数中渲染新增用户模板 为新增用户表单指定请求地址，请求方式，为表单项添加name属性 增加实现添加用户的功能路由 接收到客户端传递过来的参数 对请求参数格式进行验证 验证当前要注册的邮箱地址是否已经注册过 对密码进行加密处理 将用户信息添加到数据库 重定向到用户列表页面 5.1 输入验证 Joijavascript对象的规则描述和验证器 npm install joi 5.2 完整实现 6. 用户列表 6.1 完整显示 6.2 分页显示当数据库中数量非常多时，数据需要分批显示，这时就需要用到数据分页功能 核心要素： 当前页，用户通过点击上一页或下一页产生，客户端通过get参数方式传递到服务器端 总页数，根据总页数判断当前页面是否是最后一页，根据判断结果做响应操作 mongodb限制查询 limit(2) // 限制查询数量 传入每页数据数量 skip() // 跳过查询条目数量 传入每页数据的开始位置 6.3 完整实现 6.4 修改用户7.数据分页mongoose-sex-page 8.mongodb数据库添加账号 以管理员身份运行PowerShell 连接数据库mongo 查看数据库 show dbs 切换到admin数据库 use admin 创建超级管理员账号 db.createUser() db.createUser(&#123;user:&#39;root&#39;,pwd:&#39;LINKSTART&#39;,roles:[&#39;root&#39;]&#125; 切换到blog数据 use blog 创建普通账号 db.createUser() db.createUser(&#123;user:&#39;blogadmin&#39;,pwd:&#39;admin&#39;,roles:[&#39;readWrite&#39;]&#125;) 卸载mongodb服务 停止服务 net stop mongodb mongod –remove 创建mongodb服务 启动mongodb服务 在项目中使用账号连接数据库 mongoose.connect(‘mongodb://blogadmin:LINKSTART@localhost:/blog’) 9.开发环境与生产环境环境，就是指项目运行的地方，当项目处于开发阶段，项目运行在开放人员的电脑上，项目所处的环境就是开发环境。当项目开发完成以后，将项目发到真实的网站服务器中运行，项目所处的环境就是生产环境。 为什么要区分开发环境与生成环境 因为在不同的环境中，项目的配置是不一样的，需要在项目代码中判断当前项目的运行环境，根据不同的环境应用不同的配置 将当前环境设置进系统变量之中。 npm install morgan app.use(morgan(&#39;dev&#39;)); 10.config允许开发人员将不同运行环境下的应用配置信息抽离到单独的文件中，模块内部会自动判断当前应用的运行环境，并读取对应的配置信息，极大降低了提供应用配置信息的维护成本，避免了当运行环境重复多次切换时，手动到代码中修改配置信息 npm install config 新建 config 文件 /config/ 新建 default.json, development.json, production.json require导入 使用模块内部提供的get方法获取配置信息 将敏感信息存储在环境变量中 11.文章评论 创建评论集合 判断用户是否登录，如果用户登录，再允许用户提交评论表单 在服务器端创建文章评论功能对应路由 在路由请求处理函数中接收客户端传递过来的评论信息 将评论信息存储在评论集合中 将页面重定向到文章详情页面 "},{"title":"WEB API","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-WEBAPI/","categories":["FrontEnd"],"content":"Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API （BOM 和 DOM)。如控制浏览器窗口，访问浏览器历史等等… MDN WEB API1. Web APIs 和 JS 基础关联性1.1 JS 的组成 1.2 关联性js 基础阶段 ECMAScirpt 标准规定基本语法 无法做出网页交互效果 Js基础 Web APIs 阶段 W3C 组织标准 DOM 和BOM 网页交互 需要拥有 Js 基础 JS 基础学习 ECMASCript 基础语法为后面铺垫，Web APIs 是 JS 的应用，大量使用 JS 基础语法做交互效果 2. API 和 Web API2.1 APIAPI (Application Programming Interface) 应用程序接口，是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制细节。 即只关心实现，不深入原理。 2.2 Web APIWeb API 是浏览器提供的一套操作浏览器功能和页面元素的 API （BOM 和 DOM)。 MDN详细 API :  2.3 总结 API 是为程序员提供的接口，帮助我们实现某些功能，我们会使用即可，无需纠结内部实现 Web API 主要是对于浏览器提供的接口，主要针对浏览器的交互效果 Web API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法 "},{"title":"PC端常见网页特效","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-pc-web-effect/","tags":["Web Design"],"categories":["FrontEnd"],"content":"元素偏移 offsetoffset 偏移量，使用 offset 系列相关属性可以动态的得到该元素的位置（偏移），大小等。 获得元素距离带有定位的父元素位置 position 获得元素自身的宽度和高度 其返回数值不带单位 offset 常用属性 属性 作用 element.offsetParent 返回作为该元素带有定位的父级元素 如果父级元素都没有定位则返回 body element.offsetTop 返回元素相对带有定位父元素上方的偏移 element.offsetLeft 返回元素相对带有定位父元素左边框的偏移 element.offsetWidth 返回自身包括 padding ，border，内容区的宽度 不含单位 element.offsetHeight 返回自身包括 padding ，边框，内容区的高度度 不含单位 偏移量计算是没有 right 和 bottom 的。 offset 与 style 区别 offset` 可以得到任意样式表中的样式值 offset 系列获得的数值没有单位 offsetWitdh 包含 pandding border width offsetWitdh 等属性是只读属性，只能获取不能赋值 style 只能得到行内样式表中的样式值 style.width 获得的是带有单位的字符串 style.width 获得不包含 pandding 和 border 的值 style.width 是可读写属性，可以获取也可以赋值 样式表 css 有行内样式，内嵌样式，外链样式。 案例：获取鼠标在盒子内的坐标 在盒子内点击，得到鼠标距离盒子左右的距离 首先得到鼠标在页面中的坐标 e.pageX e.pageY 其次得到盒子在页面中的距离 box.offsetLeft box.offsetTop 用鼠标在页面中的坐标减去盒子在页面的距离，即可得到鼠标在盒子里的坐标 如果想移动鼠标就得到参数，应该使用 mouseover 事件 案例：模态框拖拽 需求： 点击弹出按钮，弹出模态框，并且显示灰色半透明的遮挡层 点击关闭按钮后，可以关闭模态框，并且同时关闭灰色半透明遮挡层 鼠标放到模态框最上面的一行，可以按住鼠标拖拽模态框 鼠标松开，停止拖拽 实现思路： 点击弹出层，模态框和遮挡层就会显示出来 display:block 点击关闭按钮，模态框和遮挡层就会隐藏 display:none 在页面拖拽的原理：鼠标按下 mousedown 并且移动 mousemove ，之后松开鼠标 mouseup 鼠标的坐标减去鼠标在盒子内的坐标，才是模态框的真正位置 案例：图片放大 需求： 当用户鼠标触摸小图片时，出现可移动透明遮罩，并在相应位置出现遮罩内的放大内容。 实现思路： 鼠标经过小图片盒子，遮罩层和大图片盒子显示，离开隐藏 遮挡层跟随鼠标移动 移动遮挡层。大图片跟随移动 首先获得鼠标在盒子的坐标 之后把数值给遮挡层赋值 left top，注意调整高宽度的一半，使鼠标在遮挡层居中 要想遮挡层不能超出小图片盒子，添加判断条件，当遮挡层的宽高度小于或超过将其设置为0和相应距离 大图片移动距离公式： 遮挡层移动距离/遮挡层最大移动距离 = 大图片移动距离/大图片最大移动距离 元素可视区 clientclient 客户端，我们使用 client 相关属性来获取元素可视区的相关信息，动态的得到该元素的边框大小，元素大小 属性 说明 element.clientTop 返回元素上边框的大小 element.clentLeft 返回元素左边框的大小 element.clentWidth 返回自身包括 padding ，内容区宽度，不含边框，返回不带单位 element.clentHeight 返回自身包括 padding ，内容区高度，不含边框，返回不带单位 立即执行函数 立即执行函数无需调用，声明即使用 其主要作用是：创建了应该独立的作用域，避免了命名冲突 pageshow 与 load 事件的区别 pageshow 事件是当页面加载时触发，无论加载是否来自缓存，注意这个事件是 window 下的方法，通过 e.persisted 判断页面是否来自缓存 load 事件虽然也是当页面加载时触发，但是无法在加载缓存时触发 元素滚动 scroll使用 scroll 相关属性方法可以动态得到该元素的大小，滚动距离等 属性 说明 element.scrollTop 返回被卷去的上侧距离，不带单位 element.scrollLeft 返回被卷去的左侧距离，不带单位 element.scrollWidth 返回自身实际宽度，不含边框，不带单位 element.scrollHeight 返回自身实际高度，不含边框，不带单位 offset ，client 和 scroll 的区别总结 offset 用于获取元素位置 client 用于获取元素大小 scroll 用于获取元素滚动距离 mouseover 和 mouseenter 事件的区别 mouseover 鼠标经过自身或子盒子都会触发，mouseenter 只会触发经过自身 mouseenter 不会冒泡，mouseover 则会冒泡。 案例：悬浮工具栏 实现思路： 页面滚动事件 onscroll ，事件源 document 判断页面滚动距离 window.pageYoffset onscroll 滚动事件，当滚动条发生变化触发该事件。 动画函数封装动画实现原理 通过定时器 setInterval 不断使元素移动 基本步骤： 获得元素当前位置 让盒子在当前位置上移动 通过定时器不断重复 加一个结束定时器的条件 移动元素必须添加定位才能移动 动画函数简单封装 注意函数需要传递两个参数，动画对象和移动到的距离 给不同的元素设置不同的定时器 从封装函数不难看出，每次声明这个函数都要开辟一个函数空间，而且每次都声明了同一个定时器，这样造成了性能浪费 JS 是一门动态语言，可以很方便的给当前对象添加属性 定时器清除，避免定时器叠加 缓动效果原理 缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 思路： 让盒子每次移动的距离逐渐变小，速度就会慢下来 核心算法：（目标值 - 现在位置）/ 10 做为每次步长 当盒子位置等于目标位置就停止定时器 动画函数添加回调函数 callback 传递一个函数即可。 动画函数封装到单独 JS 文件 将函数抽离单独存放在一个 js 文件中，在项目需要使用时，引入该文件即可 案例：工具栏显示隐藏 常见网页特效轮播图需求： 鼠标触摸 banner 显示切换按钮，移除鼠标则隐藏 动态生成 banner 图片计数 计数圆点的排他思想 节流阀 防止快速连续点击轮播按钮造成播放速度叠加 bug 当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法触发 利用回调函数，添加变量来控制，锁住和解锁函数 回到顶部滚动窗口至文档中的特定位置 "},{"title":"移动端常见网页特效","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-moblie-web-effect/","tags":["Web Design"],"categories":["FrontEnd"],"content":"触屏事件移动端浏览器兼容性较好，我们不需要考虑 JS 兼容问题，可以放心使用原生 js 书写效果，但是移动端也有自己独特的地方，比如触屏事件 touch 。 touch 对象代表一个触摸点，触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可以响应用户手指对屏幕或触控板的操作。 常见的触屏事件： 事件 说明 touchstart 触摸到一个 DOM 元素时触发 touchmove 在一个 DOM 上滑动时触发 touchend 手指从一个 DOM 元素上移开时触发 触摸事件对象 touchstart , touchmove ,touchend 三个事件都有各自的事件对象 TouchEvent 是一类描述手指在触摸平面的状态变化的事件。这类事件作用与描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等。 属性对象 说明 touches 正在触摸屏幕的所有手指的一个列表 targetTouches 正在触摸当前 DOM 元素上的手指的一个列表 changedTouches 手指状态发生了改变的列表，从无到有，从有到无 移动端拖动元素 touchstarts,touchmove,touchend 可以实现拖动元素 但是拖动元素需要当前手指的坐标值，我们可以使用 tarfetTouches[0] 里的 pageX 和 pageY 在手指移动时计算出手指移动距离，然后用盒子原来的位置加上手指移动的距离 实现关键： 触摸元素 touchstart ：获取手指初始坐标，同时获得盒子原来的位置 移动手指 touchmove ： 计算手指的滑动距离，并且移动盒子 离开手指 touchend 手指移动也会触发滚动屏幕，所以这里要阻止默认的屏幕滚动 e.preventDefalut() 移动端常见特效轮播图 自动播放功能 开启定时器 移动端移动，可以使用 transale 移动 添加过渡效果 transition 无缝滚动 判断条件应等到图片滚动完毕后再去判断，就是过渡完成后判断 过渡完成检测事件 transitionend 如果索引号是最后一张，说明已经完成一个流程，此时索引号复原 注意需要去除过渡效果 圆点跟随变化 把 ol 里面 li 带有 current 类名的选出来去点类名 classList.remove 让当前索引的加上 classList.add current 类 classList 属性是 HTML5 新增的一个属性，返回元素的类名。 该属性用于在元素中添加，移除以及切换 css 类。 添加类： 删除类： 切换类： click 延时解决方案 移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放页面 （double tap to zoom） 解决方案： 禁止用户缩放 利用 touch 事件封装函数解决 使用 fastclick 插件（见移动端常用开发插件） Github：fastclick 移动端常用开发插件移动端要求的是快速开发，所以我们经常会借助一些插件来帮助我们完成操作。 JS 插件是 js 文件，它遵循一定的规范编写，方便程序展示效果，拥有特定的功能且方便调用。如轮播图和瀑布流插件。 特点：专门为了解决某个问题而存在，功能单一，体积较小 插件使用： 引入 JS 文件。 查看文档说明。 Swiper  superslide  iscroll  移动端视频插件 zy.media.js 移动端常用开发框架框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方法。构架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发 Bootstrap中文网 Vue.js"},{"title":"Express 初步使用","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/BackEnd-2020-8-Express-Start/","tags":["Node.js","Express"],"categories":["FrontEnd","BackEnd"],"content":" Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架 Express 基础入门官方文档：Express Doc 什么是 ExpressExpress是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用 Express 框架特性 提供了方便简洁的路由定义方式 对获取HTTP请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态HTML页面 提供了中间件机制有效控制HTTP请求 拥有大量第三方中间件对功能进行扩展 路由对比 请求参数对比 Express 初体验使用Express框架创建web服务器及其简单，调用express模块返回的函数即可。 Express 安装部署在命令行使用npm工具进行下载express 在项目主js文件引入express Express中间件中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 什么是中间件中间件主要由两部分构成，中间件方法以及请求处理函数。 中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。 中间件规则 可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。 默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。 中间件方法传递请求：next() 默认情况下依照代码顺序匹配中间件，一但匹配成功就终止。可以调用next() 将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。调用 next() 方法需要在回调函数参数中属性 next 参数 接收所有请求：use() use方法可以匹配所有请求方法 use方法接收请求后会终止请求，请求将不会传递 中间件应用场景验证用户登录 网站维护 404页面定义 错误处理中间件 在程序执行过程中，会不可避免的出现一些无法预料的错误，比如文件读取失败，数据库连接失败。 错误处理中间件是一个集中处理错误的地方。 Express模块化路由 Express请求处理GET参数获取Express中使用 req.query 即可获取GET参数，框架内部会将GET参数转化为对象并返回。 POST参数获取Express中接收post参数需要借助express提供的模块包 body-parse 使用： 路由参数 静态资源处理通过express下的 express.static 可以方便的托管静态文件，例如 img，css，javascripe 等静态资源 Express模板引擎为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template。 app.locals 对象 将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。 "},{"title":"初识 MongoDB","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/BackEnd-2020-8-MongoDB-Base/","tags":["MongoDB"],"categories":["BackEnd"],"content":" MongoDB 是一个基于分布式文件存储非关系数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 基础语法官方文档：Getting Started MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 数据结构MongDB 所有的数据都是以 json 对象进行存储的 在进行数据库结构设计时务必参照 JSON 标准。 MongoDB术语 参照 SQL术语 理解 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 安装部署下载中心 MongoDB Download Center mongodb 社区版下载 MongoDB Community mongodb 图形界面管理工具（可选） MongoDB Compass 使用引导安装在命令行操作 mongodb 时请务必使用管理员权限打开命令行窗口 所有的安装设置都会在引导界面设置完成，之后通过命令行操作数据库服务 启动服务 停止服务 移除服务 连接管理 使用命令行安装移除服务后需要手动以命令行方式进行安装 添加系统变量虽然这步不是必须的，但是在使用 mongodb 过程中某些命令需要系统变量的支持。 MongoDB安装目录下的bin路径导入到系统变量Path中。 设置身份验证初次安装时是没有设置身份验证的，任何人都可以访问你的数据库，这样是十分危险的。接下来将为 mongodb 部署强制身份验证。 在命令行窗口运行以下命令，确保 mongodb 服务在你的系统上存在 如果显示以下字段，说明 mogodb 服务正在运行 使用命令行打开运行 mongo.exe 切换到 admin 数据库 新建超级管理员账户 验证是否创建成功 卸载 mongodb 服务 创建 mongodb 服务 注意 -auth 参数 如果您已成功完成本指南，则已在本地 MongoDB 实例上启用了基本身份验证。 添加数据库用户在添加数据库用户之前您必须拥有超级管理员账号。 连接到数据库 admin 进行身份验证，之后切换到需要创建管理账户的数据库中使用 db.createUser 进行创建。 注意只有切换到响应的数据库之后才能进行身份验证或用户创建，否则会出现验证失败和创建失败。 连接数据库未启用身份验证如果你未启用身份验证，您可以容易的使用命令行进入数据库 在 Compass 中只需要点击 connect 即可，无需配置 启用身份验证如果你启用了身份验证，在使用 Compass 连接时需要填写 URL ，url的填写规则为 在命令行中启动 mongo.exe 切换到正确数据库之后使用 db.auth(&quot;name&quot;,&quot;pwd&quot;) 来进行验证 命令行进入 mongo.exe 并不需要验证，但是这样是无法查看或修改任何数据的 API你可以访问 MongoDB Drivers 来获取您语言操作数据库的 API 本文档只介绍 Node.js 对 Mongodb 的连接操作。 在 node.js 下操作 mongodb 您需要使用到第三方模块 mongoose 您可以通过 npm 管理工具进行下载 之后您可以在 js 文件中引入 mongoose 并使用它来连接数据库。 数据库操作访问 MongoDB Drivers 来获取您语言操作数据库的 API ，下面我们只介绍使用 mongo.exe 命令行对数据库的操作。 创建数据库MongoDB 创建数据库的语法格式如下： 这个方法在没有该数据库时会创建该数据库，否则会转到该数据库，注意，如果创建数据库时没有添加该数据库内容，是不会显示该数据库的。 如果你想查看所有数据库，可以使用 show dbs 命令： 删除数据库MongoDB 删除数据库的语法格式如下： 您需要使用 use dbname 来切换到需要删除的数据库才能执行删除操作。 创建集合 如果要查看已有集合，可以使用 show collections 或 show tables 命令： 删除集合 插入文档 以上代码会将花括号内的 json 对象插入到 col 集合中，如果集合不存在数据库会自动创建。 导入文档mongoimport -d 数据库名称 -c 集合名称 -file 导入目标文件 使用mongoimport命令需要将MongoDB安装目录下的bin路径导入到系统变量Path中 更新文档 删除文档 查询文档"},{"title":"DOM 事件基础","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/FontEnd-2020-8-DOM-event-base/","tags":["DOM"],"categories":["FrontEnd"],"content":"文档对象模型 （Document Object Model) ，是 W3C 组织推荐的 HTML 或 XML 的标准编程接口。 即我们常说的 DOM树。 DOM1. DOM 简介文档对象模型 （Document Object Model) ，是 W3C 组织推荐的 HTML 或 XML 的标准编程接口。 W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容，结构和样式。 2. DOM 树 文档：一个页面就是一个文档，DOM 中使用 document 表示 元素：页面中的所有标签都是元素，DOM 中使用 element 表示 节点：网页中所有的内容都是节点（标签，属性，文本，注释等），DOM 中使用 node 表示 3. DOM 操作3.1 获取元素3.1.1 获取页面元素因为所有元素都是在 document 下的，通过 document 对象进行获取 document.function() 根据 ID 获取 getElementById() 返回 object 根据标签名获取 getElementByTagName() 以 object 数组形式返回 element.getElementByTagName() 获取元素中的所有标签 通过 HTML5 新增方法获取 getElementByClassName() 根据类名获取 object 数组 querySelector(&#39;./#选择器&#39;) 返回指定选择器的第一个元素对象 querySelectAll(&#39;./#选择器&#39;) 返回指定选择器的所有元素对象 特殊元素获取 获取 body 标签 document.body 获取 html 标签 document.documentElement console.dir(object) 能打印出当前对象的所有属性和方法 3.2 事件基础3.2.1 事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些触发 javaScript 的事件。 事件源：事件被触发的对象 事件类型：如何触发 如鼠标触摸，鼠标点击等 事件处理程序：函数 使用事件三要素对网页效果进行分析能很迅速明了的了解网页实现方式 3.2.2 执行事件步骤 获取事件源 注册事件 添加事件处理函数 3.3 操作元素javascript 的 DOM 操作可以改变网页内容，结构样式，我们可以利用 DOM 操作元素来改变元素的内容，属性等。 3.3.1 改变元素内容 从起始位置到终止位置的内容，但它去除 html 标签，同时空格和换行也会去掉 起始位置到终止位置全部内容，保留 html 标签，编译 html 3.3.2 操作元素属性哪些是属性 src style id alt title 等等，即除了标签之外，标签内包含的代码。 3.3.3 获取元素属性 3.3.4 移除元素属性 3.3.5 表单元素操作不同于其它元素，操作表单元素有些许不同 案例：分时问候需求：根据不同的时间在页面上显示不同的问候语 实现思路： 获取系统时间，和页面展示元素 添加事件，判断时间，不同的时间修改不同的元素内容 案例：显示密码需求：用户在填写密码表单时，提供一个按钮，用户点击按钮可以显示密码和关闭显示密码 实现思路： 为按钮添加事件，修改表单的 type 属性 设置变量 flag 判断按钮状态 通过这个方法能迅速窃取别人的密码，现在的浏览器都有自动填充功能，一但有人通过页面元素修改 input 的 type 属性，自动填充的密码很容易就会暴露给别人。 3.4 操作样式3.4.1 操作 style 修改样式我们可以通过 js 修改元素的样式 style 3.4.2 操作 class 修改样式当需要大量改变元素的样式时，我们可以新增 class ，通过操作元素 class 属性添加 classname。 3.4.3 排他思想应用场景：当出现一组组件，触摸其中一个组件更改样式，其余其他组件恢复原来样式。 实现思路： 通过两组 for 循环遍历组件 第一次循环恢复所有组件样式 第二次循环为组件添加事件改变样式 3.4.4 H5 自定义属性自定义属性的目的：未您保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 自定义属性通过 getAttribute(&#39;name&#39;) 来获取 但是有些属性很难判断是数据标准属性还是自定义属性，容易引起歧义 所以 H5 规定了自定义属性语法 H5 新增 element.dataset.attr 或者 element.dataset[&#39;attr&#39;] 案例：点击隐藏图片需求: 用户点击按钮,隐藏一张图片 实现思路: 为 button 添加事件,修改图片 div 的 display 属性 案例：循环图片表应用场景：在某些页面需要大量规律插入图片时 优雅的做法应该是通过 js 动态操作图片文件名，图片文件名的命名应该有规律，便于 js 循环，这样通过循环为列表添加不同图片。 案例：显隐文本框内容需求： 当用户点击输入框时，不显示输入框的内容，失去焦点时，展示回来原本建议。 但是当用户输入文本再失去焦点时要展示用户输入，没有输入时重新显示原本的建议。 此外当用户输入时，颜色加深，失去焦点时颜色变浅。 实现思路： 获得焦点 onfocus 失去焦点 onblur 为两个事件添加判断文本框的 value 属性 为两个事件修改文本框 style.color 属性 案例：输入提示需求： 当输入框失去焦点，展示提示信息 当用户输入错误，显示错误提示信息 当用户输入正确，显示正确提示 实现思路： 为输入框添加获取焦点事件 onfocus 并显示展示信息 输入监控，判断输入，展示相应提示 案例：百度换肤需求：用户从图片组点击图片时，更换页面背景为点击图片。 实现思路： 为图片组注册事件 添加事件函数修改页面背景 传递点击图片的 src 给页面 bg 案例：表格触摸反馈需求：鼠标触摸该行时样式加深 实现思路： 为每个 tr 添加鼠标经过事件 onmouseover 和鼠标离开事件 onmouseout，改变样式 使用 for 为 td 设置背景样式 案例：表单全选取消全选需求： 新增全选案例，点击案例勾选全部项目，取消则取消全选 用户手动全选时，全选按钮需要打勾 用户手动取消全选时，取消勾选全选按钮 实现思路： 为全选按钮添加点击事件，判断选择状态，并用 for 循环设置其余选择的 checked 状态 为所有的其余按钮添加事件，在事件中 for 判断所有按钮状态，为全选按钮设置相应状态 案例：tab栏切换需求： 当鼠标点击选项卡 tab ,下面的内容跟随变化 实现思路： 为每个 tab 标签添加 index 属性，通过 index 确定需要展示的 div ::: details ::: 3.5 节点操作3.5.1 什么是节点操作获取元素通常使用两种方式： 利用 DOM 提供的方法获取元素 document.getElementById() document.getElementByTagName() document.querySelector() 逻辑性不强，繁琐 利用节点层级关系获取元素 利用节点关系获取元素 逻辑性强，兼容性差 3.5.2 节点概述页面中所有的内容都是节点，在 DOM 中节点使用 node 表示。 HTML DOM 中所有的节点都可以通过 js 访问，所有 HTML 元素节点均可以被修改，也可以被创建或删除。 一般的，节点至少拥有 nodeType （节点类型），nodeName （节点名称），nodeValue（节点值）这三个要素。 元素节点 nodeType 为 1 属性节点 nodeType 为 2 文本节点 nodeType 为 3 3.5.3 节点层级利用 DOM 树可以把节点划分为不同的层级关系，如复制，兄弟关系。 父级节点 子节点 兄弟节点 3.5.4 节点操作 3.5.5 三种动态创建元素的区别 案例：下拉菜单 导航栏里的 li 都要有鼠标经过事件，所以需要循环注册事件 当鼠标经过 li 显示该 li 下的 ul 案例：发布留言需求：用户在 input 输入文本点击提交按钮后，将输入信息追加在页面区域。 实现思路： 点击按钮后，动态创建一个 li ，追加到页面 案例：删除留言实现思路： 当我们插入留言时，多添加一个删除按钮 获取按钮，添加点击事件 阻止链接跳转 javascrip:; 案例：动态生成表格需求：在表格中点击增加按钮添加数据，点击删除按钮，删除相应数据。 实现思路： 所有数据都是存放在 tbody 里，使用循环创建 tr，通过数组长度判断行数 通过循环数据对象创建 td 创建删除单元格 为删除添加事件 3.6 DOM 核心总结DOM 元素是一个对象 object ，所以称 DOM 为文档对象模型 DOM 操作主要是对于元素的 增删改查，属性操作，事件操作 创建 document.write innerHTML createElement 增 appendChild insertBefore 删 removeChild 改 修改元素属性 element.attr src title href 等 修改自定义元素 element.getAttribute(&#39;attr&#39;,&#39;new&#39;) 修改普通元素内容 innerHTML innerText 修改表单元素：value,type,disabled 修改元素样式：style,className 查 DOM 提供的 API ：getElementByID,getElementsByTagName H5 提供的新方法：querySelector,querySelectorAll 利用节点操作获取元素：父(parentNode) 子 (children) 兄 (previousElementSibling,nextElementSibling) 属性操作 主要针对自定义属性 setAttribute getAttribute removeAttribute 事件操作 事件三要素 事件源，事件类型，事件处理程序 onclick onmouseover onfocus onblur …"},{"title":"MongoDB Node.js使用实例","date":"2020-08-06T16:00:00.000Z","url":"/blog/2020/08/07/BackEnd-2020-8-MongDB-nodejs-example/","tags":["Node.js","MongoDB"],"categories":["BackEnd"],"content":" MongoDB Node.js使用实例环境部署Nodejs  npm [nodejs package manager] 是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题 MongoDB  version require: 4.2.7 MongoDB 可视化界面管理软件 Compass  nodejs 操作 mongoDB 需要依赖第三方包 mongoose npm instaall mongoose 服务启动与连接 启动 MongoDB 服务 net start mongodb 关闭 MongoDB 服务 net stop mongodb js调用API连接数据库 数据库增删改查 制定集合规则 创建插入文档 使用CMD导入文件文档mongoimport -d 数据库名称 -c 集合名称 -file 导入目标文件 使用mongoimport命令需要将MongoDB安装目录下的bin路径导入到系统变量Path中 查询文档 删除文档 更新文档 验证 优雅的验证错误抓取 集合关联 文章集合 用户集合 _id _id title name author age content habbies 使用id对集合进行关联 populate方法进行关联查询 案例实战用户信息管理系统 搭建网站服务器，实现客户端与服务端的通信 连接数据库，创建用户集合，向集合中插入文档 当用户访问/list时，将所有用户信息查询出来 将用户信息和表格HTML进行拼接并将拼接结果响应给客户端 当用户访问/add时，呈现表单页面，并实现添加用户信息功能 当用户访问/modify时，呈现修改页面，并实现修改用户信息功能 当用户访问/delete时，实现用户删除功能 ::: details ::: 代码优化 模块化 模板引擎art-template art-template 是一个简约、超快的模板引擎。它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。 参考链接  官方文档  使用命令 npm install art-template 进行安装 使用 const template = require(&quot;art-template&quot;) 引入模板引擎 告诉模板引擎要拼接的数据和模板文件 const html = template(&quot;path&quot;,data) 模板引擎语法标准语法 原始语法 1. 输出::: v-pre &#123;&#123;data&#125;&#125;::: &lt;%=data %&gt; 可在花括号内使用简单的逻辑运算 + - x / = ?: 等 2. HTML输出::: v-pre &#123;&#123;@data&#125;&#125;::: &lt;%- data %&gt; 3. 条件判断 4. 循环::: v-pre &#123;&#123;each data&#125;&#125; &#123;&#123;/each&#125;&#125;::: &lt;% for() &#123;%> "},{"title":"依托于GithubPages的Vuepress静态博客GithubAction自动部署方案","date":"2020-08-03T16:00:00.000Z","url":"/blog/2020/08/04/FontEnd-2020-8-StaticBlogAutoDeployPlan/","tags":["Git","Github","Github Pages","Github Action","Vuepress","Gitee"],"categories":["FrontEnd"],"content":"博客发表流程： 项目文件下新建 Markdown 文章 git push 借助 GithubAction 实现 Github &amp; Gitee 双端自动部署。 开始之前 这是我的第一个博客网站，前后花费了差不多一个星期，期间参考了大量博文，文档。 总结建站前后的经验写下第一篇关于本博客的部署教程的博文，希望能够帮助和我一样摸索建站的人。 ​ 于朝阳升起处，我将踏上旅程 项目描述 一个基于 Vuepress 第三方主题 vuepress-theme-reco 搭建的静态博客 托管项目代码在 Github 仓库，并使用 Github Pages 服务运行网站。 使用 Github Action 实现自动编译部署。 使用 Github Action 实现同步推送仓库代码至 Gitee 和更新 Gitee Pages 服务。 Github My Blog :  Gitee My Blog :  项目优越 纯静态页面，无需后台数据库。 Github Pages 服务，无需单独服务器。 Git 更新，管理网站。 Github Action 自动部署，专注写作。 Gitee 同步推送，自动更新 Gitee Pages , 更好的国内访问体验 项目技术 本项目使用 Vuepress 第三方主题 vuepress-theme-reco 构建，在开始之前你应该对 Vuepress 有一个基本了解，并对其构建流程有一定的初步掌握。 强烈建议按照官方文档在个人电脑上构建一个官方的 Vuepress 项目，以便更好的开始使用接下来的 Vuepress 第三方博客主题。 除此之外，你还需要掌握基本的 Git 使用方法以及对 Github 仓库各项配置的理解和使用，包括 Github Action 的初步认知。 Vuepress 中文文档 vuepress-theme-reco 官方文档 阮一峰 GitHub Actions 入门教程 快速开始npx npm yarn 一切就绪后按照提示，进入项目目录，并安装依赖 (本文之后都将使用 npm 进行管理) 通过命令行键入以下命令，并访问监听端口即可查看网站 修改配置网站的各项信息配置存储在了 .vuepress/config.js 通过修改 config.js 文件，你可以修改替换网站的大部分预设内容，如 网站标题，logo图标，导航栏Tab选项卡等等。 .vuepress/config.js 可以分为以下几个部分 基本配置 title description 等等 主题配置 theme themeConfig 插件配置 plugins Markdown 配置 markdown 其中的各项属性说明和配置方法你均可在 Vuepress 配置 ，Vuepress 默认主题配置 和 reco Config.js 中查询得到。 请自行参考文档说明替换相应属性值。 网站的静态资源存储在了 .vuepress/public 目录下，其设定了全局的相对路径，你只需要以 / 开头对其进行直接引用。 比如替换网站的 logo 图片为 .vuepress/public/web-img/logo.png 关于主题的夜间模式配置请单独参考： 暗色模式适配 404 腾讯公益关闭方法： 这里需要额外注意 base 和 dest 属性： base 类型: string 默认值: / 部署站点的基础路径，如果你想让你的网站部署到一个子路径下，你将需要设置它。如 GitHub pages，如果你想将你的网站部署到 ，那么 base 应该被设置成 &quot;/bar/&quot;，它的值应当总是以斜杠开始，并以斜杠结束。 base 将会作为前缀自动地插入到所有以 / 开始的其他选项的链接中，所以你只需要指定一次。 dest 类型: string 默认值: .vuepress/dist 指定 vuepress build 的输出目录。如果传入的是相对路径，则会基于 process.cwd() 进行解析。 此处先做提醒可不做添加或修改，在 部署上线 步骤中再做详细讲解。 运行命令，查看修改 ![]( =700x) 首页配置更换博客首页的 Banner 或 slogan 是单独在项目根目录下的 README.md 文件进行的。 由于 reco 首页配置 已经详细介绍，这里不再进行赘述。 reco 提供了三种首页样式，在 npx reco主题时，提供了选择支。 blog式 文档式 午后南杂 如果你需要从文档式切换至blog式，只需修改 .vuepress/config.js 主题配置的 type 属性 修改完成后，运行命令，查看修改 ![]( =700x) 自定样式如果你不满足于主题提供的默认样式，VuePress 提供了一些简单的接口文件，可以让你能够很方便地定制你自己想要的效果。 修改主题颜色你可以通过配置 .vuepress/styles/palette.styl （手动创建）来快速修改主题的一些颜色属性。 色彩网站：日式传统色 测试配色可读性：Color.review 修改主题样式你可以创建一个 .vuepress/styles/index.styl文件以方便地添加额外样式。这是一个 Stylus 文件，但你也可以使用正常的 CSS 语法。 在网站任何可以访问的页面都可以通过 index.styl 文件书写 CSS 样式，通过浏览器开发者工具我们能够十分轻松的选择元素并添加或修改样式。 如果你对样式修改没有头绪可以参考其他使用 reco主题的博客样式并自行修改 reco 优秀博客案例 如果你需要本博客的自定义样式，可以访问博客仓库 qijieh/blog 运行 npm run dev 查看我们修改的样式 ![]( =700x) ![]( =700x) 引用脚本与样式你可以通过配置 .vuepress/config.js 中的 head 来引入自己的js脚本与样式。 通过外挂css和js来对主题样式曾铁，例如点击效果，花瓣雨等等特效。 比如上面的配置就会被解析为 关于 head 的详细配置说明请参考官方文档 head 配置 以引入鼠标点击效果为例： 在.vuepress\\public\\js文件夹下创建MouseClickEffect.js文件，填入以下代码 然后在主题配置文件config.js下的head引入以上js，这里的jquery必须引入，鼠标点击代码才能生效 参考博文：vuepress-theme-reco个人向优化 添加文章在开始插件配置之前，先向网站添加几篇文章。 通过查看项目目录不难发现博客文章被存储在了 blogs 下，除此之外还有另外一个名为 docs 的目录存储文档文件。如果你的博客网站不需要文档类型的博文，可以删除改 docs 目录并删除 config.js 中的 themeConfig &gt; nav 中的 Docs Tab选项。 在 reco issue 中提到： Q：文章的存放位置有规定吗？ A：你可以将你的文章存放在任意位置，但是你需要保证它是 VuePress 可以解析的位置，比如你使用的命令是 vuepress dev docs ，那么请将所有文章存放在 docs/ 中，但是主题并不会强制你放在哪个子目录，这个按照你的喜好来即可，详情见 详细的 VuePress 目录结构配置。 尽管主题对文章存放位置没有硬性要求，但是你的项目结构应该保持整洁，建议沿用默认的存储路径。 比如有当前一篇文章 Vue框架学习记录.md 拥有以下 Front Matter ： 那么它的存储路径应该为 blogs/FrontEnd/2020-8/Vue框架学习记录.md 。 主题不会根据你的文件路径来进行文章分类，而是对 Markdown 文件的 Front Matter 中的相关标签进行分类解析。 但是为了保持项目结构整洁请务必设置路径为分类名称。 Vuepress Front Matter reco Front Matter 示例 根据具体场景新建md文章，并修改存储路径。删除主题的测试文章，添加一篇自己的测试博文 （建议长度一定，拥有标题结构和代码块，方便后期测试）。 这是一个博文存储结构的示例： 向文章添加摘要，显示在博文列表中 reco 添加摘要 更多 Vuepress Markdown 支持语法请查看： Vuepress Markdown扩展 存储博文时务必以英文命名，否则可能导致 URL 混乱 添加完成后，运行命令，查看添加成功与否 ![]( =700x) ![]( =700x) 插件配置关于插件的配置语法 Vuepress 插件 中已经详细说明，请自行参考文档了解其语法和使用方法。 至此一个完整的博客已经配置出来，但是如果你需要其他需求如 背景音乐播放器，live2d看板娘，代码快捷复制， markdown语法扩展等等，可以通过导入第三方插件来完善你的博客。 reco 主题已经内置了一些实用的插件，这些插件已经完全足够博客基本功能。点击查看 但是你依旧可以通过访问 vuepress插件社区 或 reco主题插件广场 来新添插件。 你可以通过这种方式来对主题内置插件的配置进行覆盖，甚至禁用一个内置插件 只需将 Options 设置成 false 便可禁用该插件 就像这样 接下来引入一个音乐播放器插件 meting 做为示例 install 插件 在 .vuepress/config.js 文件中引入插件并按照插件文档配置相关属性 npm run dev 查看效果 ![]( =700x) 对于新增的播放器，你也可以通过 .vuepress/styles/index.styl 来为其修改样式 在浏览器通过开发者工具选中播放器，查看元素类名 Vuepress Styling 下面将列出推荐的插件链接： meting ：简单易用的播放器插件，支持自动解析网易云单曲/歌单链接 @vuepress/pwa ：网页内容更新提醒 vuepress-plugin-nuggets-style-copy ：为代码块添加复杂按钮，并在复制成功后弹出提示信息 flowechart ：使你的 Markdown 支持 flow 流程图 img-lazy ：图片惰性加载 copyright ：控制网站的复制行为 vuepress-plugin-smooth-scroll ：更圆滑的页面滚动 插件的安装引入大同小异，请自行参照插件文档进行配置。 由于评论插件 Vssue （ 已集合到 reco 自带插件 comments 中）的特殊性（需要配置项目仓库）将放在 部署上线 之后再进行配置 部署上线在正式开始部署上线之前，你应该对 vuepress 的构建流程有一个大致了解。 之前我们使用的 npm run dev 模式运行了 vuepress 的开发模式，这个模式下是不会产生我们需要的静态资源的。 只有运行 npm run build 时才会在指定目录下构建出我们的博客网页 命令行运行 npm run build ，检查在 .vuepress/dist 下是否能构建出资源文件。 Error: cannot find module ‘../dist/manifest/client.json’ 如果在构建过程中出现此项错误，你的系统环境变量中可能设置了 NODE_ENV : development 将其修改为 NODE_ENV ：production 即可。 详情查看 vue.js issue 双端部署本博客同时部署到了 Github 和 Gitee 上，你可以尝试访问 Github My Blog :  Gitee My Blog :  在此之前你应该明白 Github 和 Gitee 的 Pages 服务差异 Github 允许用户使用个人域名即 https://[userName].github.io ，只需要在创建仓库时将仓库命名为 [userName].github.io 即可 但是 Gitee 却不允许用户使用个人域名，即无论创建仓库命名为何，都只能指向 https://[userName].gitee.io/[repoName] 这种差异增加了我们博客双端部署的难度，因为 Vuepress 对于部署到非根路径的项目有着相应配置参考 基础路径 ，如果对部署到二级路径的项目没有设置 config.js 文件中的 base 值，将会导致网页资源的错误加载。 综上所述，为了保持项目的一致性我们不得不放弃使用 Github 提供的个人域名，去与 Gitee 保持一致使用二级域名，这也是为什么上方两个博客链接都不是非根路径的原因所在。 ::: tip 如果你只需要部署到一个平台，请酌情参考本博文。 ::: 新建仓库 登录 Github 新建仓库，仓库命名自定，本博文以 blog 命名仓库。 如果你需要进行双端部署切勿命名为 [userName].github.io ，详见上方说明。 如果你只想部署在 Github 推荐以 [userName].github.io 命名。 其实命名为 blog 会导致博客 Url 混乱，因为reco主题的 router 设置了 /blogs/ 路由，将会导致出现这样的访问链接：  建议命名为：space ，personal ，room 等等 登录 Gitee 新建仓库，建议仓库名与 Github 仓库名一致，方便访问。 部署方式 部署方式分为两种 手动部署 和 自动部署，两种部署方式唯一的区别在于是否需要本地编译 npm run build 出网页源码。 其详细流程如下： 手动部署 （易） 书写博文 或 修改主题 构建网页文件 npm run build git push 自动部署 （难） 书写博文 或 修改主题 git push 自动部署会在服务器端进行网页的构建和编译 npm run build，而不是在开发机上，管理员只需要专注于文章写作，构建部署工作全部交由服务器端完成。 尽管自动部署方案在实行时可能会花费大量时间成本，但是仍然建议你使用自动部署方案，感受 Github Action 的强大之处，并且其一旦完成，后期的维护成本将明显降低。 ::: warning 注意！！！只有自动部署方案才能实现 Gitee 的代码同步和 GiteePages 的自动更新，如果你需要将你的博客网站如同本博客一样在双平台自动部署，请参考自动部署方案。 ::: 手动部署由于 GithubPages 服务的渲染目录只预设了 root 和 docs ，我们得重新指定 build 的输出目录，将其重新设定为 docs 这样 npm run build 的文件便会生成在 docs 目录下。 构建并上传 注意新建 .gitignore 文件 上传完成之后，我们需要打开 Github 仓库页面，配置项目的 GithubPages 服务。 点击 仓库Setting 下拉找到 GithuPages 在 Source 中设置如下 注意设置为 /docs 目录，而不是默认的 /root ，这样 GithubPages 就会解析我们 /docs 目录下的博客网页了。 现在点击上方的网址访问你的博客吧。 现在你的博客发布流程为： 写博客 或 修改主题 npm run build git push Gitee 同步解决方案 ::: warning 手动部署方案适合单仓库部署，如果你执意双端部署将会明显提高维护成本。 ::: 打开创建的 Gitee 仓库 管理 &gt; 基本设置 &gt; 仓库远程地址 输入 Github 的仓库地址 ![]( =750x) 返回仓库代码页，点击仓库名旁边的同步按钮完成推送 ![]( =750x) 这样 Github 仓库的代码便会同步至该仓库下，接下来只需要开启该仓库的 Gitee Pages 服务 ：服务 &gt; Gitee Pages ![]( =750x) 点击链接访问你的网站吧。 为什么不推荐手动部署的双端托管？ 首先你得知道 Gitee 仓库的同步功能是不支持自动同步的，也就是说，即使你更新了 Github 仓库的代码，Gitee 这边仍然需要你过来手动点击同步按钮来更新同步。 同样糟糕的是 Gitee Pages 服务和 Github Pages 服务不同，使用 GitHub Pages 时，每当项目有更新，GitHub 会自动帮我们重新部署 GitHub Pages。而 Gitee Pages 则不会如此，它仍需要你点击 Pages 服务的更新按钮来刷新内容！或者开通 Gitee Pages Pro 功能。而 Pro 功能的开通，需要满足以下其中一个条件： 花钱开通 Pro 功能，￥99/年。 Gitee 项目足够优秀，得到 Gitee 官方的推荐，那么 Gitee 就会提示“您的项目为推荐项目，已自动为您开通 Gitee Pages Pro。 这样将意为着每次你在 Github 轻松完成了git push ，你仍然需要登录你的 Gitee 仓库点击强制同步按钮拉取代码，再去点击 Pages 服务的刷新按钮更新网页。 手动部署双端托管的博客发布流程： 写文章 npm run build git push 登录 Gitee 仓库 点击强制同步按钮 点击 Pages 服务的更新按钮 显然这是十分不友好的，但是当你只部署在 Github 平台上时就可以不用管 Gitee 了。 自动部署如果你阅读了上方手动部署的解决方案，可以深感其的不便性，特别是进行 Github 和 Gitee 双平台托管的场景时。 接下来的部署方案，将让你从繁杂的提交流程中抽离出来，让你更加专注博客内容，而不是操心与网站的部署。 现在我们在 Github 和 Gitee 上各拥有一个 blog 仓库，而我们的自动部署方案将在 Github 上进行，借助于 Github Action 我们能够优雅的实现两个仓库的自动同步更新。 初识GithubActionGitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。 Automate your workflow from idea to productionGitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want. 关于 Github Action 的初步入门教程可以参考 阮一峰 GitHub Actions 入门教程 ，其中也大致介绍了什么是 Github Action 。 如果你对 Github Action 感兴趣，希望深入了解其语法结构可以自行查阅 官方文档 编写workflows文件要想使用 Github Action 我们得在项目根目录下创建 .github/workflows/main.yml 。 GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 .github/workflows/main.yml： ::: details ::: ::: warning 注意 YAML 语法对于Tab缩进有着严格要求，请务必确保代码缩进格式正确！！！ ::: 以上是本博客的 workflows 流程，如果你熟悉 Github 和 Gitee 的相关配置你可以直接套用并替换相关属性即可。当然，我也会在下方逐一带领配置。 首先确保你的 main.yml 文件路径正确，此时你的项目结构应该大致为： 关于 .gitignore 文件说明： 由于现在方案的编译环节 npm run build 交由了 Github Action 完成，我们不再需要上传生成的静态文件目录 接下来将会对 .github/workflows/main.yml 代码进行逐一讲解配置。 基本字段说明1. name name 字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。 2. on on 字段指定触发 workflow 的条件，通常是某些事件。 当推送至 master 分支时，触发 workflow。 3. jobs jobs 字段是 workflow 的主体当满足 on 的条件时就会运行 jobs 中的各项任务 4. needs needs 字段当前 job 的依赖关系，只有当 needs 中的 job 运行完成后才会执行当前 job 其可以是一个 job 数组 [job1,job2] 5. runs-on 当前 job 运行的虚拟机环境，必填字段 可用虚拟机如下 ubuntu-latest，ubuntu-18.04 或 ubuntu-16.04 windows-latest，windows-2019 或 windows-2016 macOS-latest 或 macOS-10.14 6.steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 name：步骤名称。 use ：使用市场发布的 action 脚本 run：该步骤运行的命令或者 action。 env：该步骤所需的环境变量。 with ：额外配置信息 将 action 抽离出来，并设立市场复用代码正是 Github Action 的优越之处，在 Markplace 中发布了大量的 action 脚本，你可以直接在 yml 文件中以代码仓库的方式引用。 工作流程梳理main.yml 的工作流程可以总结为： 每当代码 push 到 master分支 时触发 wrokflow ，其一共有两个 job 执行 build-and-deploy 任务，其分为三步 step Checkout ：使用了 actions/checkout 拉取代码到虚拟机 build ：在虚拟机运行命令行 npm install &amp;&amp; npm run build 就是在这一步服务器帮我们编译生成了网页数据 Deploy ：使用 JamesIves/github-pages-deploy-action 将生成的网页源码部署到 gh-pages 分支上 当 build-and-deploy 执行完毕后，运行 sync-to-gitee 任务，其一共有两步 step Sync to Gitee ：使用 wearerequired/git-mirror-action 强制同步 Gitee 仓库 Build Gitee Pages ：使用 yanglbme/gitee-pages-action 更新 Gitee Pages 服务，设置 gh-pages 分支的根目录为渲染目录 ::: warning 注意：在自动部署方案中，我们不再使用单分支开发，我们将额外创建一个独立分支 gh-pages 用来托管生成的网页源码。 我们的项目分支结构应该为： master ：存储 vuepress 构建代码 gh-pages ：存储编译生成的网页源码 该分支必须命名为 gh-pages ，否则无法使用 Github Pages 服务，你无需手动创建，JamesIves/github-pages-deploy-action 会自动帮我们创建该分支。 ::: workflow敏感数据在某些 step 中，访问仓库，操作仓库等等一系列操作，会需要进行身份验证，这样就涉及到一些仓库令牌，访问密码之类的敏感数值，我们不能直接将其明文暴露在 yml 文件中，所以我们使用了系统环境变量的方式存储在了你的仓库（虚拟机）中，通过::: v-pre$&#123;&#123; secret.NAME &#125;&#125;:::方法，能让我们从虚拟机中拿到这些数值。 接下来我们将逐个生成和设置这些敏感数据 Deploy 在这一步中虚拟机会将 FOLDER 下的生成内容推送至 Github 仓库的 gh-pages 分支，所以需要一个仓库的访问令牌，你可以参考 官方文档 创建个人访问令牌 ，生成一个用于命令行访问仓库的个人令牌。 个人头像 &gt; Setting &gt; Developer settings &gt; Personal access tokens &gt; Generate new token ![]( =780x) Note 仅用于提示令牌信息，**需要注意勾选 Scopes 中的 repo 和 workflow**，点击 Generate token 按钮生成 token ![]( =780x) 之后页面会跳转会 Personal access token ，并出现蓝色提示框，里面的字符串便是生成的个人令牌，这串数值只会显示这一次，当你离开当前页面后就会被永久隐藏，请务必保管好。 ![]( =780x) 虽然你可以将其直接复制到 .giyhub/workflowes/main.yml 文件的 Deploy.with.ACCESS_TOKEN ，但是这样是十分不安全的。接下来我们将其保存至仓库的 Secrets 下。 Secrets are environment variables that are encrypted and only exposed to selected actions. Anyone with collaborator access to this repository can use these secrets in a workflow. Secrets 相当于当前虚拟机的系统环境变量，在该仓库运行的 workflow 文件可以通过::: v-pre$&#123;&#123;secrets.NAME&#125;&#125;:::访问这些系统变量。 仓库 &gt; Setting &gt; Secrets &gt; New Secrets 按照以下方式填写 Name 是存储系统环境变量的名称，你可以随意填写只需修改 workflow 文件中的变量名即可。点击 Add secret 即可完成仓库系统环境的添加，只后只要在 workflow 文件中以::: v-pre$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;:::的方式即可访问预先设置好的环境变量。 &#123;5&#125; Sync to Gitee 在这一步中 action 会完成 Gitee 仓库代码的同步，这里将会使用 SSH公私钥配对 的方式进行 Gitee 身份验证。如果你熟悉 Github SSH 的配布方式可以自行设置。 生成新 SSH 密钥 如果你计算机中曾经设置过 Github 或 Gitee 的 SSH 服务可以跳过此步。 打开 Git Bash。 键入以下命令。 提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。 在提示时输入安全密码。 更多信息请参阅“使用 SSH 密钥密码”。 运行上面步骤后在你的 /c/Users/you/.ssh/ 目录下会拥有两个文件 你可以通过文本方式打开文件进行查看，接下来只需要将 id_rsa_pub 上传至远程仓库即可。 这里参考的是 Github 的中文文档（文档比 Gitee 详细），SSH 公私钥生成是 Git 提供的服务，文档通用 。 Github 和 Gitee 都是基于 SSH 协议的 Git 服务，如果你在 Github 已经配置了 SSH ，你完全可以使用同一份公钥在 Gitee ，这样我们只使用一个私钥在两个平台都能进行验证。这里只需要在 Gitee 设置 SSH 。 Gitee SSH 公钥设置 注意此处我们需要生成的是 账户SSH Key 不是 仓库SSH Key，其区别如下： 和仓库”只读”权限的 SSH Key 相比，账户的 SSH Key 同时具备推送/拉取的权限，对用户创建/参与的仓库均能使用，使用起来更加方便。 主页右上角 「个人设置」-&gt;「安全设置」-&gt;「SSH公钥」-&gt;「添加公钥」 ，添加生成的 public key 添加到当前账户中。 点击确定即可，可以不用管 SHA256 。 接下来，只需要将配套的将我们的 私钥id_rsa 储存在 Github 仓库的 Secrects 中，这样 workflow文件就能通过读取系统环境变量::: v-pre$&#123;&#123;secrect.Name&#125;&#125;:::的方式用私钥与 Gitee 上的公钥进行配对，以此验证身份，获得仓库操作权限。 Github 仓库 &gt; Setting &gt; Secrets &gt; New Secrets 通过::: v-pre$&#123;&#123; secrtes.GITEE_RSA_PRIVATE_KEY &#125;&#125;:::与 Gitee 仓库进行 SSH 验证，获得 Gitee 仓库的操作权限。 &#123;5&#125; Build Gitee Pages 完成代码的同步后，我们需要更新 Gitee Pages 服务，刷新网页内容。 Gitee Pages 服务不支持自动更新，开通会员的 Gitee Pages Pro 服务将支持。 该 yanglbme/gitee-pages-action 的 Action 应该是使用了类似网页脚本的方法替代了手动点击 Gitee Pages 的更新按钮。 注意：该 action 需要事先开启 Gitee 仓库的 Pages 服务才能正常运行。但是此时我们的 Gitee 仓库还是为空，无法启动 Gitee Pages 服务，所以你需要在第一次推送后手动前往 Gitee Pages 开启。 这个 action 需要我们提供 Gitee 的账户密码，我们依旧将其存放在 Github 仓库的 Secrtes 中。 Github 仓库 &gt; Setting &gt; Secrets &gt; New Secrets 点击 Add secret ，这样 workflow 文件便可以提供系统环境变量的方式::: v-pre$&#123;&#123; GITEE_PASSWORD &#125;&#125;:::访问到我们的 Gitee 账户密码。 &#123;8&#125; Vssue评论插件 ![]( =700x) Vssue 是一款无需后台的评论系统，其由 Vue 驱动并基于 Github 仓库的 Issue 实现。被广泛运用于博客，文档等无后端评论场景。 由于其配置需要 Github 仓库的 Issue 所以需要通过 Github OAuth Apps 的接口数据。 由于 reco 主题已经将 Vssue 集合在了官方插件 comment 中，我们无需额外 npm install ，通过参考 文档 在项目的 .vuepress/config.js 中引入插件 &#123;13,14&#125; 其中的 owner 填写仓库拥有者，repo 填写仓库名称，clientId 和 clientSecret 需要前往 Github 仓库设置。 我个人仓库的地址是  配置如下： 依次点击 Github 的 个人头像 &gt; Setting &gt; Developer setting &gt; OAuth Apps &gt; New OAuth App Homepage URL ：需要授权的网址 Authorization callback URL ：授权回调地址 请自行修改该属性，填写完成后点击 Register application 提交。 只后我们在 OAuth Apps 列表便可以看见列表了，点击其进入 ![]( =700x) 其中的 Client ID 和 Client Secret 便是 Vssue 插件需要的配置值了。 将 Client ID 和 Client Secret 直接填写在 config.js 的 Vssue 插件配置中是不理智的，我们依旧可以使用 Github 仓库的 Secret 来存储这两个值，在 workflow 的编译 build 阶段将其以::: v-pre$&#123;&#123; secret.Name &#125;&#125;:::的方式访问其值。 ![]( =700x) 这里不再详细说明设置方法，请自行参考之前几个 Secret 的配置教程。 添加成功后在我们的 workflow 文件中添加相应代码，将其添加进编译过程的环境中 &#123;5,6&#125; 这样在虚拟机运行时在环境中就拥有了 VSSUEID 和 VSSUESECRET 两个变量，而 node 为我们提供在一个 process.env 方法，让我们能够在编译的时候访问当前进程的环境变量，我们只需要在 config.js 的 Vssue 配置中使用该方法即可 &#123;13,14&#125; 开始推送确保你已经替换 workflow 文件中的数据，并在 Github 和 Gitee 设置好了相应配置。检查你的 main.yml 文件是否正确存储在路径 .github/workflows/ 下。 一切准备就绪后开始你的 Git 流程，并见证 Github Action 的强大。 推送完成后，打开 Github仓库的 Actions 按照图片依次点击进入 Action 运行日志 ![]( =700x) ![]( =700x) 之后你便可以看见你的 workflow 文件正在被逐一执行。 绿勾代表执行成功 黄色代表正在执行 红叉代表执行出错 你可以在这里检查出错原因，请根据原因自行 debug ，这里列出几个常见的错误： main.yml 语法错误，请检查Tab缩进 ![]( =600x) 仓库操作错误，令牌或密码配置不正确，请根据该步骤需要的数据检查 ![]( =600x) 部分 action 配置错误，以下错误是以为在 Deploy 中设置生成目录 .vuepress/dist ，却在 config.js 中设置 dest 为 docs ，导致虚拟机编译 npm run build 后没有生成文件在 .vuepress/dist 下，进而致使 Deploy 环节无法从 .vuepress/dist 目录拉取代码到 gh-pages 分支。 &#123;10&#125; &#123;2&#125; ![]( =680x) 当所有的 Action 正常执行完成后，你可以查看 Github 仓库是否更新了 gh-pages 分支，其是否存储了网页源码。 ![]( =700x) 再访问你的 Gitee 仓库查看其是否同步了代码和分支。 ![]( =700x) ![]( =700x) 接下来你只需要手动配置一次两个仓库的 Pages 服务。 ![]( =700x) ![]( =700x) 之后便无需操心，每次提交 Github Action 都会为你完成一系列的工作。 访问你的博客至此所有的自动部署已经完成，现在你的博客提交流程为： 书写博文，修改主题 git push Github Action 在你看不见的地方为了完成了一系列操作： 从仓库拉取代码 编译代码，生成网页源码，并推送到 gh-pages 分支 同步 Gitee 代码 更新 Gitee Pages 服务 现在，访问你的博客网站吧！ 图床搭建尽管你可以在 Markdown 文件中使用相对路径对项目下的 public 文件夹的图片进行引用，但是这样做无疑增加了我们仓库的容量占用，特别是当网站中引用大量图片时，我们不可能全部将其存储在 public 文件夹下，这对网站性能和仓库容量都是一种极大的浪费。 对此我选择了 PicGo + Gitee 在线图床的解决方案。借助于第三方的在线图床服务，我们可以在 Markdown 文件中通过 src 的方式访问在线的图片。 下载 PicGo 软件至你的电脑，安装并打开。 在插件设置中搜索 gitee 并安装插件。 ![]( =700x) 安装成功后，打开 图床设置 &gt; Gitee图床 ![]( =700x) owner ：仓库所有者 repo ：仓库名称 token ：个人令牌 访问 Gitee 创建图床仓库 ![]( =700x) 注意勾选 使用Readme文件初始化这个仓库 点击 个人头像 &gt; 设置 &gt; 私人令牌 &gt; 生成新令牌 ![]( =700x) 点击提交之后，令牌token会出现，请复制妥善保存。将其填入 PicGo 图床设置 &gt; Gitee图床 &gt; token 栏中。 以我的仓库为例： ![]( =700x) 应该填写： ![]( =700x) 之后保持 PicGo 后台运行，当你的剪切板有图片或图片URL时，使用快捷键 Crtl + Shift + P 快速上传图片至仓库，随后你的剪切板将会返回图片的引用代码。 ![]( =700x) 在此处可以选择引用何种代码片段。 PicGo 除了支持 Gitee 外还支持其他图床，你可以自行百度配置。 Gitee 单仓库容量 500M Github 单仓库容量 1G SM.MS 容量 5G ，但是上传有时间限制 SEO优化todo…"}]